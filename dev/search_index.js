var documenterSearchIndex = {"docs":
[{"location":"model/nonlinear_responses.html#Nonlinear-responses","page":"Nonlinear responses","title":"Nonlinear responses","text":"","category":"section"},{"location":"model/nonlinear_responses.html#Kerr-effect","page":"Nonlinear responses","title":"Kerr effect","text":"","category":"section"},{"location":"model/nonlinear_responses.html#Photoionisation-and-plasma","page":"Nonlinear responses","title":"Photoionisation & plasma","text":"","category":"section"},{"location":"model/nonlinear_responses.html#Raman-response","page":"Nonlinear responses","title":"Raman response","text":"","category":"section"},{"location":"modules/Modes.html#Modes.jl","page":"Modes.jl","title":"Modes.jl","text":"","category":"section"},{"location":"modules/Modes.html#Luna.Modes.AbstractMode","page":"Modes.jl","title":"Luna.Modes.AbstractMode","text":"AbstractMode\n\nAbstract type representing a single mode of a waveguide.\n\n\n\n\n\n","category":"type"},{"location":"modules/Modes.html#Luna.Modes.ToSpace-Tuple{Any}","page":"Modes.jl","title":"Luna.Modes.ToSpace","text":"ToSpace(ms; components=:xy)\n\nConstruct a ToSpace for high performance conversion between modal fields and real space.\n\nArguments\n\nms::Tuple: a tuple of modes\ncomponents::Symbol: which polarisation components to return: :x, :y, :xy\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.Aeff-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.Aeff","text":"Aeff(m::AbstractMode; z=0.0)\n\nGet effective area of mode m and longitudinal position z.\n\nThis is the brute-force implementation valid for any mode.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.Exy-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.Exy","text":"Exy(m::AbstractMode, xs; z=0.0)\n\nGet the normalised field components at position xs, z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.Exy-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.Exy","text":"Exy(m::AbstractMode; z=0.0)\n\nCreate function that returns normalised (xs) -> (Ex, Ey)\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.N-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.N","text":"N(m::AbstractMode; z=0.0)\n\nGet mode normalization constant of mode m at longitudinal position z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.absE-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.absE","text":"absE(m::AbstractMode, xs; z=0.0)\n\nGet the field norm E at position xs, z\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.absE-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.absE","text":"absE(m::AbstractMode; z=0.0)\n\nCreate function that returns normalised (xs) -> E.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.arbitrary-Tuple{}","page":"Modes.jl","title":"Luna.Modes.arbitrary","text":"arbitrary(kwargs...)\n\nCreate an arbitrary mode, which takes its methods from given functions. \n\nThe functions given should have the same signature as defined Luna.Modes, except that the first argument (the AbstractMode) is omitted, e.g. for neff the function should be of the form n(ω; z) = ...\n\nTo define neff with functions for α and β, create the neff function using neff_from_αβ.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.chkzkwarg-Tuple{Any}","page":"Modes.jl","title":"Luna.Modes.chkzkwarg","text":"chkzkwarg(func)\n\nCheck that function accepts z keyword argument and add it if necessary.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.dB_per_m-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.dB_per_m","text":"dB_per_m(m::AbstractMode, ω; z=0.0)\n\nCalculate the attenuation in dB/m for the mode m at frequency ω and longitudinal position z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.delegated-Tuple{Any}","page":"Modes.jl","title":"Luna.Modes.delegated","text":"delegated(mode, kwargs...)\n\nCreate a delegated mode, which takes its methods from an existing mode except for those which are overwritten\n\nArguments:\n\nmode::AbstractMode: The wrapped mode to which non-specified methods are delegated\nkwargs: functions that override: neff, field, dimlimits, Aeff, or N.\n\nThe functions given should have the same signature as the mode methods, i.e. take an AbstractMode as their first argument, even if they do not do anything with it. This is to ensure that the delegated functions can access the data of the wrapped mode if necessary.\n\nTo override neff with functions for α and β, create the neff function using neff_from_αβ.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.dimlimits","page":"Modes.jl","title":"Luna.Modes.dimlimits","text":"dimlimits(m::AbstractMode; z=0.0)\n\nMaximum dimensional limits of validity for mode m at position z.\n\n\n\n\n\n","category":"function"},{"location":"modules/Modes.html#Luna.Modes.dispersion-Tuple{Luna.Modes.AbstractMode, Any, Any}","page":"Modes.jl","title":"Luna.Modes.dispersion","text":"dispersion_func(m::AbstractMode, order; z=0.0)\n\nCalculate the dispersion of a given order at frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.dispersion_func-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.dispersion_func","text":"dispersion_func(m::AbstractMode, order; z=0.0)\n\nGet a function βn(ω) which returns the dispersion of a given order at frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.field","page":"Modes.jl","title":"Luna.Modes.field","text":"field(m::AbstractMode, xs; z=0.0)\n\nGet the field components (Ex, Ey)at positionxs,z`\n\n\n\n\n\n","category":"function"},{"location":"modules/Modes.html#Luna.Modes.field-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.field","text":"field(m::AbstractMode; z=0)\n\nCreate function of coords that returns (xs) -> (Ex, Ey) for the mode m.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.losslength-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.losslength","text":"losslength(m::AbstractMode, ω; z=0.0)\n\nCalculate the losslength (1α) for the mode m at frequency ω and longitudinal position z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.neff","page":"Modes.jl","title":"Luna.Modes.neff","text":"neff(m::AbstractMode, ω; z=0.0)\n\nGet the full complex refractive index of mode m at frequency ω and longitudinal position z.\n\n\n\n\n\n","category":"function"},{"location":"modules/Modes.html#Luna.Modes.neff_from_αβ-Tuple{Any, Any}","page":"Modes.jl","title":"Luna.Modes.neff_from_αβ","text":"neff_from_αβ(α, β)\n\nCreate a closure converting the functions α(ω; z) and β(ω; z) into an effective index.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.orthogonal-Tuple{Luna.Modes.AbstractMode, Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.orthogonal","text":"orthogonal(mode1, mode2)\n\nTest whether the AbstractModes mode1 and mode2 are orthogonal to each other.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.orthonormal-Tuple{Any}","page":"Modes.jl","title":"Luna.Modes.orthonormal","text":"orthonormal(modes)\n\nTest whether the modes form an orthonormal set.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.overlap-Tuple{Luna.Modes.AbstractMode, Any, Any}","page":"Modes.jl","title":"Luna.Modes.overlap","text":"overlap(m::AbstractMode, r, E; dim)\n\nCalculate mode overlap between radially symmetric field and radially symmetric mode.\n\nExamples\n\njulia> a = 100e-6;\njulia> m = Capillary.MarcatiliMode(a, :He, 1.0);\njulia> unm = approx_besselroots(0, 1)[end]\njulia> r = collect(range(0, a, length=512));\njulia> Er = besselj.(0, unm*r/a);\n\njulia> η = Modes.overlap(m, r, Er; dim=1);\njulia> abs2(η[1]) ≈ 1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.overlap-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.overlap","text":"overlap(m::AbstractMode, E)\n\nCalculate mode overlap between (analytic) 2D field E and mode m. The field function E(xs) should return the normalised cartesian vector components of the field (Ex, Ey) as an SVector as a function of polar coordinates xs = (r,θ). ```\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.overlap-Tuple{Luna.Modes.AbstractMode, Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.overlap","text":"overlap(mode1, mode2)\n\nCalculate the normalised overlap between two AbstractModes.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.overlap-Tuple{Union{Tuple{Vararg{Luna.Modes.AbstractMode}}, AbstractArray{T} where T<:Luna.Modes.AbstractMode}, Luna.Grid.RealGrid, Luna.Grid.RealGrid, Any, Any}","page":"Modes.jl","title":"Luna.Modes.overlap","text":"overlap(modes::ModeCollection, newgrid, oldgrid, r, Eωr)\n\nDecompose the spatio-spectral field Eωr, sampled on radial coordinate r and time-grid oldgrid, into the given modes and resample onto newgrid via cubic interpolation.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.to_space!-Tuple{Any, Any, Any, Luna.Modes.ToSpace}","page":"Modes.jl","title":"Luna.Modes.to_space!","text":"to_space!(Erω, Emω, xs, ts::ToSpace; z=0.0)\n\nConvert from modal fields to real space using provided ToSpace struct.\n\nArguments\n\nErω::Array{ComplexF64}: a dimension nω x npol array where the real space frequency domain                           field will be written to\nEmω::Array{ComplexF64}: a dimension nω x nmodes array containing the frequency domain                           modal fields\nxs:Tuple: the transverse coordinates, x,y for cartesian, r,θ for polar\nts::ToSpace: the corresponding ToSpace struct\nz::Real: the axial position\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.to_space-Tuple{Any, Any, Any}","page":"Modes.jl","title":"Luna.Modes.to_space","text":"to_space(Emω, xs, ms; components=:xy, z=0.0)\n\nConvert from modal fields to real space.\n\nArguments\n\nEmω::Array{ComplexF64}: a dimension nω x nmodes array containing the frequency domain                           modal fields\nxs:Tuple: the transverse coordinates, x,y for cartesian, r,θ for polar\nms::Tuple: a tuple of modes\ncomponents::Symbol: which polarisation components to return: :x, :y, :xy\nz::Real: the axial position\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.to_space-Tuple{Any, Any, Luna.Modes.ToSpace}","page":"Modes.jl","title":"Luna.Modes.to_space","text":"to_space(Emω, xs, ts::ToSpace; z=0.0)\n\nConvert from modal fields to real space using provided ToSpace struct.\n\nArguments\n\nEmω::Array{ComplexF64}: a dimension nω x nmodes array containing the frequency domain                           modal fields\nxs:Tuple: the transverse coordinates, x,y for cartesian, r,θ for polar\nts::ToSpace: the corresponding ToSpace struct\nz::Real: the axial position\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.transmission-Tuple{Luna.Modes.AbstractMode, Any, Any}","page":"Modes.jl","title":"Luna.Modes.transmission","text":"transmission(m::AbstractMode, ω, L)\n\nCalculate the power transmission after propagation through length L in the mode m for radiation at the frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.zdw-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.zdw","text":"zdw(m::AbstractMode, λ0; z=0.0, rtol=1e-4)\n\nCalculate the zero-dispersion wavelength (ZDW) of mode m with an initial guess of λ0.\n\nThis method is faster than the bounded version if the ZDW is known to be close to λ0.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.zdw-Tuple{Luna.Modes.AbstractMode}","page":"Modes.jl","title":"Luna.Modes.zdw","text":"zdw(m::AbstractMode; λmin=100e-9, λmax=3000e-9, z=0.0)\n\nCalculate the zero-dispersion wavelength (ZDW) of mode m within the range ub to lb.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.α-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.α","text":"α(m::AbstractMode, ω; z=0.0)\n\nCalculate the attenuation constant α for the mode m at frequency ω and longitudinal position z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.β-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.β","text":"β(m::AbstractMode, ω; z=0.0)\n\nCalculate the propagation constant β for the mode m at frequency ω and longitudinal position z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Modes.html#Luna.Modes.β_ret-Tuple{Luna.Modes.AbstractMode, Any}","page":"Modes.jl","title":"Luna.Modes.β_ret","text":"β_ret(m::AbstractMode, ω; z=0, λ0)\n\nCalculate the propagation constant β for mode m transformed into a frame which moves with the group and phase velocity of m at wavelength λ0.\n\n\n\n\n\n","category":"method"},{"location":"scans.html#Parameter-scans","page":"Parameter scans","title":"Parameter scans","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Luna comes with a flexible interface to run, save and process scans over any parameter or combination of parameters you can think of. A simple example can be found in examples/simple_interface/scan.jl, and we will go through it here. There are only a few necessary steps to run a parameter scan.","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"First, define the fixed parameters (those which are not being scanned over):","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"using Luna\nimport PyPlot: plt\n\na = 125e-6\nflength = 3\ngas = :He\nλ0 = 800e-9\nτfwhm = 10e-15\nλlims = (100e-9, 4e-6)\ntrange = 400e-15","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Second, create the arrays which define your parameter scan. A simulation will be run at every possible combination (the Cartesian product) of these arrays. In this example we will do a pressure-energy scan from 50 μJ to 200 μJ in 16 steps and from 0.6 bar to 1.4 bar in steps of 0.4 bar:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"energies = collect(range(50e-6, 200e-6; length=16))\npressures = collect(0.6:0.4:1.4)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Third, create a Scan which will store the scan arrays and define how the scan is executed. You must give this a name. In this case, \"pressure_energy_example\". Scan variables like energies and pressures can be passed at construction time or added later:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"scan = Scan(\"pressure_energy_example\"; energy=energies)\naddvariable!(scan, :pressure, pressures)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Fourth, run the scan! Here we want to store the output of the scan in a subdirectory of the directory containing the script we're running to avoid clutter. Passing scan and scanidx to prop_capillary will mean that our output files (one for each simulation) are automatically numbered and some information about the scan being run is also stored.","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"# @__DIR__ gives the directory of the current file\noutputdir = joinpath(@__DIR__, \"scanoutput\")\n\nrunscan(scan) do scanidx, energy, pressure\n    prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,\n                   λlims, trange, scan, scanidx, filepath=outputdir)\nend","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Here, runscan uses the do-block syntax, which wraps its body in a function. In our example this function takes three arguments: scanidx, energy, pressure. Generally, scanidx is always present and uniquely identifies a specific simulation in the scan (it simply runs from 1 to the number of simulations in the scan, length(scan)). The number of subsequent arguments is equal to the number of scan variables you have added to the scan, and their order must match the order in which variables were added to the scan. Alternatively, we could also have wrapped our scan in a function ourselves:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"function runone(scanidx, energy, pressure)\n   prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,\n                   λlims, trange, scan, scanidx, filepath=outputdir)\nend\nrunscan(runone, scan)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"but the do block syntax is exactly equivalent to this and usually easier.","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"warning: Warning\nThe order in which you add the variables to the scan is important, and it must match the arguments in the do block. scan = Scan(\"pressure_energy_example\"; energy=energies, pressure=pressures) is not equivalent to scan = Scan(\"pressure_energy_example\"; pressure=pressures, energy=energies).","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Running this script will simply run all the simulations, one after the other, in the current Julia session. To alter this behaviour, Scan also takes another argument, the execution mode, which has to be a subtype of Scans.AbstractExec. For example, to run only the first 10 items in the scan, we can use a RangeExec:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"scan = Scan(\"pressure_energy_example\", Scans.RangeExec(1:10); energy=energies) # note the second argument here\naddvariable!(scan, :pressure, pressures)\noutputdir = joinpath(@__DIR__, \"scanoutput\")\n\nrunscan(scan) do scanidx, energy, pressure\n    prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,\n                   λlims, trange, scan, scanidx, filepath=outputdir)\nend","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Scans can be executed in several ways, which are defined via the various subtypes of Scans.AbstractExec:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"LocalExec: simply run the whole scan on the current machine in a for loop\nRangeExec: run a subsection of the scan as given by a UnitRange (e.g. 1:10 for the first 10 elements)\nBatchExec: divide the scan into batches and run a specific batch (can be used to balance load between processes)\nQueueExec: create a \"queue file\" which is used to balance load between several processes. This can be executed from multiple processes simultaneously. Alternatively, QueueExec can be made to spawn several subprocesses on the local machine which then use the queueing system to balance load between them.\nCondorExec: create a submission file (aka job file) for an HTCondor batch system running on the current machine and submit it, claiming a specified number of nodes, to execute the scan using a QueueExec.\nSSHExec: use one of the other AbstractExec types but first transfer the file to a remote host via SSH and then execute it. (Note: the remote machine must have Julia and Luna available with the same versions of both, and Julia must be available in a shell via the julia command.) For more details on how to set up execution over SSH, see below.","category":"page"},{"location":"scans.html#Command-line-arguments","page":"Parameter scans","title":"Command-line arguments","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Most of the above execution modes can also be triggered by running the script (the .jl file) from the command line with additional arguments. To show the options, run julia [script] --help where script is your .jl file. As one example, running our scan.jl example in queue-file mode could be accomplished by julia scan.jl --queue, and starting 4 subprocesses to share the queue could be done by julia scan.jl --queue -p 4. Importantly, command-line arguments passed to the script overwrite any explicitly created execution mode within the script.","category":"page"},{"location":"scans.html#Manual-file-naming","page":"Parameter scans","title":"Manual file naming","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"The method we used above of passing the scan and scanidx to prop_capillary is the simplest and most reliable way of creating output files in the correct order and with all the necessary information. If you need something else, for example to run a scan including two sequential propagation simulations, you can pass an additional argument filename to prop_capillary. This will then be used instead of the scan name to automatically name the files. In the low-level interface, this is possible via Output.ScanHDF5Output (which is used internally by prop_capillary), which takes a keyword argument fname. Both ways store metadata about the scan in each file (the scan arrays and their order, and the resulting shape of the scan grid).","category":"page"},{"location":"scans.html#Processing-scan-output","page":"Parameter scans","title":"Processing scan output","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"After the scan is finished, the individual simulations are stored in separate files. Processing.scanproc streamlines data processing across the scan by automatically combining the results of a single processing function when applied to all files. Continuing with our pressure-energy scan from above, say we want to plot the output spectrum as a function of energy and pressure. To do this, we can run scanproc like this (again using the do-block syntax)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"λ, Iλ, zstat, edens, max_peakpower = Processing.scanproc(outputdir) do output\n    λ, Iλ = Processing.getIω(output, :λ)\n    zstat = Processing.VarLength(output[\"stats\"][\"z\"])\n    edens = Processing.VarLength(output[\"stats\"][\"electrondensity\"])\n    max_peakpower = maximum(output[\"stats\"][\"peakpower\"])\n    Processing.Common(λ), Iλ[:, end], zstat, edens, max_peakpower\nend","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"The function here always takes one argument. This argument is a single read-only HDF5Output which contains the results from one simulation in the scan. The function then processes the results from this one simulation and returns the results. scanproc will combine the output of this processing function for each individual simulation and place it into a grid of the same shape as the original scan. In this example, Iλ has shape (Nλ, Nenergy, Npressure), because the output of the function (Iλ[:, end]) has shape (1484,):","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"julia> size(Iλ)\n(1484, 16, 3)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Because the wavelength axis is the same for all outputs, we don't need to have it repeated. By wrapping it in a Processing.Common, we tell scanproc that it only needs to return one instance:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"julia> size(λ)\n(1484,)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"With this data, we can now plot the energy-pressure scan:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"fig, axs = plt.subplots(1, length(pressures))\nfig.set_size_inches(8, 2)\nfor (pidx, pressure) in enumerate(pressures)\n    ax = axs[pidx]\n    global img = ax.pcolormesh(λ*1e9, energies*1e6, 10*Maths.log10_norm(Iλ[:, :, pidx])')\n    img.set_clim(-40, 0)\n    ax.set_xlabel(\"Wavelength (nm)\")\n    ax.set_ylabel(\"Energy (μJ)\")\n    ax.set_title(\"Pressure: $pressure bar\")\n    ax.set_xlim(100, 1200)\nend\nplt.colorbar(img, ax=axs, label=\"Energy density (dB)\")","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"which will produce this figure: (Image: Scan spectra)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Some outputs from the function may not have the same length for each simulation. For example, the length of propagation statistics arrays depends on how many steps were required in the simulation. To deal with this, we can use Processing.VarLength. Rather than a single multi-dimensional array like Iλ, scanproc will place the results into an array of arrays:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"julia> typeof(edens)\nArray{Array{Float64,1},2}\n\njulia> size(edens)\n(16, 3)\n\njulia> size(edens[1, 1])\n(169,)\n\njulia> size(edens[1, 2])\n(235,)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"For return values which are scalar, like the maximim peak power max_peakpower in our example, the resulting array simply has shape (Nenergy, Npressure):","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"julia> size(max_peakpower)\n(16, 3)","category":"page"},{"location":"scans.html#Processing-scan-results-at-runtime","page":"Parameter scans","title":"Processing scan results at runtime","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Sometimes it is not useful or required to store the whole propagation output for each simulation, but only some result from the simulation is needed. For example, we may only be interested in the output field and not its evolution along the propagation. Especially if we're running very many simulations, storing the evolution and then extracting only the last slice is very inefficient. To make this easy, you can use Output.scansave. This has to be executed within runscan and places arrays and numbers into a grid similarly to scanproc. For instance, to just store the final slice of the frequency-domain field from each simulation, along with the simulation grid, we could have used","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"runscan(scan) do scanidx, energy, pressure\n    output = prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,\n                            λlims, trange)\n    Output.scansave(scan, scanidx; grid=output[\"grid\"],\n                                   Εω=output[\"Eω\"][:, end])\nend","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Note here that scan and scanidx are not given to prop_capillary, so our output lives purely in memory without being saved to disk. If fpath is not explicitly given as a keyword argument to scansave, it automatically names the file. Here it's called pressure_energy_example_collected.h5 and is stored in the current working directory. This file then contains only the grid, the field Eω, and some metadata about the scan:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"julia> HDF5.h5open(\"pressure_energy_example_collected.h5\", \"r\") do fi\n         println(keys(fi))\n         println(size(fi[\"Εω\"]))\n       end\n[\"grid\", \"scanorder\", \"scanvariables\", \"Εω\"]\n(2049, 16, 3)","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Importantly, in our example here this file is less than one megabyte in size, whereas the scanoutput folder totals over 600 megabytes. To store the statistics as well, stats can be given as a special keyword argument to scansave. Because the arrays are not always the same size (see above), in the file these are stored in an array which is large enough to fit the longest and padded with NaNs. The number of actual statisics points available for each simulation is then stored in a special dataset valid_length.","category":"page"},{"location":"scans.html#Execution-over-SSH","page":"Parameter scans","title":"Execution over SSH","text":"","category":"section"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"Setup steps required:","category":"page"},{"location":"scans.html","page":"Parameter scans","title":"Parameter scans","text":"On the remote machine, add Julia to your path upon loading even over SSH: add export PATH=/opt/julia-1.5.1/bin:$PATH or similar to your .bashrc file above the usual check for interactive running.\nOn Windows, the default version of OpenSSH is v7, but OpenSSH v8 is required to work from within Julia. To install it:\nFollow these instructions to install the new version.\nUninstall OpenSSH via Windows Features. This removes OpenSSH 7 so that Windows finds OpenSSH 8 instead.\nSet up a public/private key pair to enable SSH login without entering a password.","category":"page"},{"location":"modules/Plotting.html#Plotting.jl","page":"Plotting.jl","title":"Plotting.jl","text":"","category":"section"},{"location":"modules/Plotting.html#Luna.Plotting.cmap_colours","page":"Plotting.jl","title":"Luna.Plotting.cmap_colours","text":"cmap_colours(num, cmap=\"viridis\"; cmin=0, cmax=0.8)\n\nMake an array of num different colours that follow the colourmap cmap between the values cmin and cmax.\n\n\n\n\n\n","category":"function"},{"location":"modules/Plotting.html#Luna.Plotting.cmap_white-Tuple{Any}","page":"Plotting.jl","title":"Luna.Plotting.cmap_white","text":"cmap_white(cmap, N=512, n=8)\n\nReplace the lowest colour stop of cmap (after splitting into n stops) with white and create a new colourmap with N stops.\n\n\n\n\n\n","category":"method"},{"location":"modules/Plotting.html#Luna.Plotting.cornertext-Tuple{Any, Any}","page":"Plotting.jl","title":"Luna.Plotting.cornertext","text":"cornertext(ax, text;\n           corner=\"ul\", pad=0.02, xpad=nothing, ypad=nothing, kwargs...)\n\nPlace a text in the axes ax in the corner defined by corner. Padding can be defined for x and y together via pad or separately via xpad and ypad. Further keyword arguments are passed to plt.text. \n\nPossible values for corner are ul, ur, ll, lr where the first letter defines upper/lower and the second defines left/right.\n\n\n\n\n\n","category":"method"},{"location":"modules/Plotting.html#Luna.Plotting.displayall-Tuple{}","page":"Plotting.jl","title":"Luna.Plotting.displayall","text":"displayall()\n\ndisplay all currently open PyPlot figures.\n\n\n\n\n\n","category":"method"},{"location":"modules/Plotting.html#Luna.Plotting.get_modes-Tuple{Any}","page":"Plotting.jl","title":"Luna.Plotting.get_modes","text":"get_modes(output)\n\nDetermine whether output contains a multimode simulation, and if so, return the names of the modes.\n\n\n\n\n\n","category":"method"},{"location":"modules/Plotting.html#Luna.Plotting.prop_2D","page":"Plotting.jl","title":"Luna.Plotting.prop_2D","text":"prop_2D(output, specaxis=:f)\n\nMake false-colour propagation plots for output, using spectral x-axis specaxis (see getIω). For multimode simulations, create one figure for each mode plus one for the sum of all modes.\n\nKeyword arguments\n\nλrange::Tuple(Float64, Float64) : x-axis limits for spectral plot (wavelength in metres)\ntrange::Tuple(Float64, Float64) : x-axis limits for time-domain plot (time in seconds)\ndBmin::Float64 : lower colour-scale limit for logarithmic spectral plot\nresolution::Real smooth the spectral energy density as defined by getIω.\n\n\n\n\n\n","category":"function"},{"location":"modules/Plotting.html#Luna.Plotting.should_log10","page":"Plotting.jl","title":"Luna.Plotting.should_log10","text":"should_log10(A, tolfac=10)\n\nFor multi-line plots, determine whether data for different lines contained in A spans a sufficiently large range that a logarithmic scale should be used. By default, this is the case when there is any point where the lines are different by more than a factor of 10.\n\n\n\n\n\n","category":"function"},{"location":"modules/Plotting.html#Luna.Plotting.spec_1D","page":"Plotting.jl","title":"Luna.Plotting.spec_1D","text":"spec_1D(output, zslice, specaxis=:λ, log10=true, log10min=1e-6)\n\nCreate lineplots of spectral-domain slices of the propagation.\n\nThe x-axis is determined by specaxis (see getIω).\n\nIf log10 is true, plot on a logarithmic scale, with a y-axis range of log10min. \n\nThe keyword argument modes selects which modes (if present) are to be plotted, and can be a single index, a range or :sum. In the latter case, the sum of modes is plotted.\n\nOther kwargs are passed onto plt.plot.\n\n\n\n\n\n","category":"function"},{"location":"modules/Plotting.html#Luna.Plotting.stats-Tuple{Any}","page":"Plotting.jl","title":"Luna.Plotting.stats","text":"stats(output; kwargs...)\n\nPlot all statistics available in output. Additional kwargs are passed onto plt.plot()\n\n\n\n\n\n","category":"method"},{"location":"modules/Plotting.html#Luna.Plotting.subplotgrid","page":"Plotting.jl","title":"Luna.Plotting.subplotgrid","text":"subplotgrid(N, portrait=true, kwargs...)\n\nCreate a figure with N subplots laid out in a grid that is as close to square as possible. If portrait is true, try to lay out the grid in portrait orientation (taller than wide), otherwise landscape (wider than tall).\n\n\n\n\n\n","category":"function"},{"location":"modules/Plotting.html#Luna.Plotting.time_1D","page":"Plotting.jl","title":"Luna.Plotting.time_1D","text":"time_1D(output, zslice, y=:Pt, kwargs...)\n\nCreate lineplots of time-domain slice(s) of the propagation.\n\nThe keyword argument y determines what is plotted: :Pt (power, default), :Esq (squared electric field) or :Et (electric field).\n\nThe keyword argument modes selects which modes (if present) are to be plotted, and can be a single index, a range or :sum. In the latter case, the sum of modes is plotted.\n\nThe keyword argument oversampling determines the amount of oversampling done before plotting.\n\nOther kwargs are passed onto plt.plot.\n\n\n\n\n\n","category":"function"},{"location":"modules/Fields.html#Fields.jl","page":"Fields.jl","title":"Fields.jl","text":"","category":"section"},{"location":"modules/Fields.html#Luna.Fields.CWField","page":"Fields.jl","title":"Luna.Fields.CWField","text":"CWField(Pavg, Aωfunc)\n\nRepresents a continuous-wave field with spectral phase/amplitude defined by Aωfunc.\n\nFields\n\nPavg::Float64: the average power\nAωfunc: a callable f(ω) to get the amplitude/phase of the field in the frequency domain\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.CWField-Tuple{Luna.Grid.EnvGrid, Any}","page":"Fields.jl","title":"Luna.Fields.CWField","text":"(c::CWField)(grid, FT)\n\nGet the field for the provided grid and Fourier transform FT\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.DataField-Tuple{Any, Any, Any}","page":"Fields.jl","title":"Luna.Fields.DataField","text":"DataField(ω, Iω, ϕω; energy, ϕ=Float64[], λ0=NaN)\n\nRepresents a field with spectral power density Iω and spectral phase ϕω, sampled on radial frequency axis ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.DataField-Tuple{Any, Any}","page":"Fields.jl","title":"Luna.Fields.DataField","text":"DataField(ω, Eω; energy, ϕ=Float64[], λ0=NaN)\n\nCreate a DataField from the complex frequency-domain field Eω sampled on radial frequency grid ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.DataField-Tuple{Any}","page":"Fields.jl","title":"Luna.Fields.DataField","text":"DataField(fpath; energy, ϕ=Float64[], λ0=NaN)\n\nCreate a DataField by loading ω, Iω, and ϕω from the file at fpath. The file must contain 3 columns:\n\nfrequency in Hz\nspectral power density (arbitrary units)\nunwrapped spectral phase\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.DataField-Tuple{Luna.Grid.AbstractGrid, Any}","page":"Fields.jl","title":"Luna.Fields.DataField","text":"(d::DataField)(grid, FT)\n\nInterpolate the DataField onto the provided grid (note the argument FT is unused).\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.PropagatedField","page":"Fields.jl","title":"Luna.Fields.PropagatedField","text":"PropagatedField(propagator!, field)\n\nA wrapper around a previously defined TimeField which applies the mutating propagation function propagator!(Eω, grid) to the field Eω.\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.PulseField","page":"Fields.jl","title":"Luna.Fields.PulseField","text":"PulseField(λ0, energy, ϕ, τ0, Itshape)\n\nRepresents a temporal pulse with shape defined by Itshape.\n\nFields\n\nλ0::Float64: the central field wavelength\nenergy::Float64: the pulse energy\npower::Float64: the pulse peak power (after applying any spectral phases)\nϕ::Vector{Float64}: spectral phases (CEP, group delay, GDD, TOD, ...)\nItshape: a callable f(t) to get the shape of the intensity/power in the time domain\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.PulseField-Tuple{Any, Any}","page":"Fields.jl","title":"Luna.Fields.PulseField","text":"(p::PulseField)(Eω, grid, energy_t, FT)\n\nAdd the field to Eω for the provided grid, energy_t function and Fourier transform FT\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.ShotNoise","page":"Fields.jl","title":"Luna.Fields.ShotNoise","text":"ShotNoise(rng=GLOBAL_RNG)\n\nCreates one photon per mode quantum noise (shot noise) to add to an input field. If no random number generator rng is provided, it defaults to GLOBAL_RNG\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.ShotNoise-2","page":"Fields.jl","title":"Luna.Fields.ShotNoise","text":"(s::ShotNoise)(Eω, grid)\n\nGet shotnoise for the provided grid. The optional parameter FT is unused and is present for interface compatibility with TimeField.\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.SpatioTemporalField","page":"Fields.jl","title":"Luna.Fields.SpatioTemporalField","text":"SpatioTemporalField(λ0, energy, ϕ, τ0, Ishape)\n\nRepresents a spatiotemporal pulse with shape defined by Ishape.\n\nFields\n\nλ0::Float64: the central field wavelength\nenergy::Float64: the pulse energy\nϕ::Float64: the CEO phase\nτ0::Float64: the temproal shift from grid time 0\nIshape: a callable f(t, xs) to get the shape of the intensity/power in the time-space domain\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.SpatioTemporalField-Tuple{Any, Any, Any}","page":"Fields.jl","title":"Luna.Fields.SpatioTemporalField","text":"(s::SpatioTemporalField)(grid, spacegrid, FT)\n\nGet the field for the provided grid, spacegrid function and Fourier transform FT\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.TimeField","page":"Fields.jl","title":"Luna.Fields.TimeField","text":"TimeField\n\nAbstract supertype for time-domain only fields.\n\n\n\n\n\n","category":"type"},{"location":"modules/Fields.html#Luna.Fields.CWSech-Tuple{}","page":"Fields.jl","title":"Luna.Fields.CWSech","text":"CWSech(;λ0, Pavg, Δλ)\n\nConstruct a CW field with Sech^2 spectral power density and random phase, with spectral full-width half-maximim of Δλ and other parameters as defined for CWField.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.GaussField-Tuple{}","page":"Fields.jl","title":"Luna.Fields.GaussField","text":"GaussField(;λ0, τfwhm, energy, ϕ, m=1)\n\nConstruct a (super)Gaussian shaped pulse with intensity/power FWHM τfwhm, either energy or peak power specified, superGaussian parameter m=1 and other parameters as defined for PulseField.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.GaussGauss-Tuple{Any, AbstractArray{T, 3} where T, Any, Any, Any}","page":"Fields.jl","title":"Luna.Fields.GaussGauss","text":"Gaussian temporal-spatial field defined on x-y grid\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.GaussGauss-Tuple{Any, AbstractVector, Any, Any, Any}","page":"Fields.jl","title":"Luna.Fields.GaussGauss","text":"Gaussian temporal-spatial field defined radially\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.GaussGaussField-Tuple{}","page":"Fields.jl","title":"Luna.Fields.GaussGaussField","text":"GaussGaussField(;λ0, τfwhm, energy, w0, ϕ=0.0, τ0=0.0, m=1)\n\nConstruct a (super)Gaussian shaped pulse with intensity/power FWHM τfwhm, superGaussian parameter m=1 and Gaussian shaped spatial profile with waist w0, propagation distance from the waist of propz, and other parameters as defined for TimeField.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.SechField-Tuple{}","page":"Fields.jl","title":"Luna.Fields.SechField","text":"SechField(;λ0, energy, τw=nothing, τfwhm=nothing, ϕ=0.0, τ0=0.0)\n\nConstruct a Sech^2(t/τw) shaped pulse, specifying either the natural width τw, or the intensity/power FWHM τfwhm, and either energy or peak power specified. Other parameters are as defined for PulseField.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.coupled_field-NTuple{4, Any}","page":"Fields.jl","title":"Luna.Fields.coupled_field","text":"coupled_field(i, mode, E, fieldfunc; energy, kwargs...)\n\nCreate an element of an input field tuple (for use in Luna.setup) based on coupling field E into a mode. The index i species the mode index. The temporal fields are  initialised using fieldfunc (e.g. one of GaussField, SechField etc.) with the same keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.energyfuncs-Tuple{Luna.Grid.RealGrid}","page":"Fields.jl","title":"Luna.Fields.energyfuncs","text":"Calculate energy from modal field E(t)\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.gauss_beam-Tuple{Any, Any}","page":"Fields.jl","title":"Luna.Fields.gauss_beam","text":"gauss_beam(k, ω0; z=0.0, pol=:y)\n\nGaussian beam field distribution with waist radius ω0 and wavenumber k, at position z from focus. pol describes the polarisation direction, one of :x or :y.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.gauss_beam_init-NTuple{4, Any}","page":"Fields.jl","title":"Luna.Fields.gauss_beam_init","text":"gauss_beam_init(modes, k, ω0, fieldfunc; energy, kwargs...)\n\nCreate an input field tuple (for use in Luna.setup) based on coupling a focused Gaussian beam with focused spot size ω0 and wavenumber k into modes. The temporal fields are initialised using fieldfunc (e.g. one of GaussField, SechField etc.) with the same keyword arguments.\n\n```jldoctest julia> a = 125e-6; julia> energy = 1e-3; julia> λ0 = 800e-9; julia> modes = (Capillary.MarcatiliMode(a, :He, 1.0, m=1), Capillary.MarcatiliMode(a, :He, 1.0, m=2)); julia> fields = Fields.gaussbeaminit(modes, 2pi/λ0, a0.64, Fields.GaussField; λ0=λ0, τfwhm=30e-15, energy=energy); julia> fields[1].fields[1].energy/energy ≈ 0.98071312 true julia> fields[2].fields[1].energy/energy ≈ 0.0061826217 true\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.make_Et-Tuple{Luna.Fields.PulseField, Luna.Grid.RealGrid}","page":"Fields.jl","title":"Luna.Fields.make_Et","text":"make_Et(p::PulseField, grid)\n\nCreate electric field for PulseField, either the field (for RealGrid) or the envelope (for EnvGrid)\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.optcomp_material-Tuple{AbstractVecOrMat, Vararg{Any, 5}}","page":"Fields.jl","title":"Luna.Fields.optcomp_material","text":"optcomp_material(Eω, grid, material, λ0; kwargs...)\n\nMaximise the peak power of the field Eω by linear propagation through the material.  Keyword arguments kwargs are the same as for prop_material.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.optcomp_taylor-Tuple{AbstractVecOrMat, Any, Any}","page":"Fields.jl","title":"Luna.Fields.optcomp_taylor","text":"optcomp_taylor(Eω, grid, λ0; order=2)\n\nMaximise the peak power of the field Eω by adding Taylor-expanded spectral phases up to order order. \n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.optfield_cep-Tuple{AbstractVector, Any}","page":"Fields.jl","title":"Luna.Fields.optfield_cep","text":"optfield_cep(Eω, grid)\n\nFind the value of the absolute phase which produces the maximal field strength in the time domain.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_material!","page":"Fields.jl","title":"Luna.Fields.prop_material!","text":"prop_material!(Eω, ω, material, thickness, λ0=nothing;\n               P=1, T=PhysData.roomtemp, lookup=nothing)\n\nLinearly propagate the frequency-domain field Eω through a certain thickness of a material. If the central wavelength λ0 is given, remove the group delay at this wavelength. Keyword arguments P (pressure), T (temperature) and lookup (whether to use lookup table instead of Sellmeier expansion).\n\n\n\n\n\n","category":"function"},{"location":"modules/Fields.html#Luna.Fields.prop_material-Tuple{Any, Vararg{Any}}","page":"Fields.jl","title":"Luna.Fields.prop_material","text":"prop_material(Eω, ω, material, thickness, λ0=nothing;\n               P=1, T=PhysData.roomtemp, lookup=nothing)\n\nReturn a copy of the frequency-domain field Eω after linear propagation through a certain thickness of a material. If the central wavelength λ0 is given, remove the group delay at this wavelength. Keyword arguments P (pressure), T (temperature) and lookup (whether to use lookup table instead of Sellmeier expansion).\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_mirror!-Tuple{Any, AbstractArray, Integer, Any}","page":"Fields.jl","title":"Luna.Fields.prop_mirror!","text":"prop_mirror!(Eω, ω, reflections, transferfunction)\nprop_mirror!(Eω, grid, reflections, transferfunction)\n\nPropagate the field Eω linearly by adding a number of reflections from a mirror with a given transfer function. transferfunction should take a single argument λ, wavelength in SI units (m), and return the complex frequency-domain response of the mirror (amplitude and phase).\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_mirror!-Tuple{Any, AbstractArray, Integer, Vararg{Any, 7}}","page":"Fields.jl","title":"Luna.Fields.prop_mirror!","text":"prop_mirror!(Eω, ω, reflections, λR, R, λGDD, GDD, λ0, λmin, λmax; kwargs...)\nprop_mirror!(Eω, grid, reflections, λR, R, λGDD, GDD, λ0, λmin, λmax; kwargs...)\n\nPropagate the field Eω linearly by adding a number of reflections from a mirror whose tabulated reflectivity and group-delay dispersion per reflection is given by:\n\nλR: wavelength samples for reflectivity in SI units (m)\nR: mirror reflectivity (between 0 and 1)\nλGDD: wavelength samples for GDD in SI units (m)\nGDD: GDD in SI units (s²)\nλ0: central wavelength (used to remove any overall group delay)\nλmin, λmax: bounds of the wavelength region to apply the transfer function over\n\nAdditional keyword arguments are passed to PhysData.process_mirror_data:\n\nfitorder: order of polynomial fit to use in removing overall group delay (default: 5)\nwindowwidth: wavelength width of the smoothing region outside (λmin, λmax)               for the window in SI units (default: 20e-9, i.e. 20 nm)\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_mirror!-Tuple{Any, AbstractArray, Symbol, Integer}","page":"Fields.jl","title":"Luna.Fields.prop_mirror!","text":"prop_mirror!(Eω, ω, reflections, mirror)\nprop_mirror!(Eω, grid, reflections, mirror)\n\nPropagate the field Eω linearly by adding a number of reflections from the mirror type.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_mirror-Tuple{Any, Vararg{Any}}","page":"Fields.jl","title":"Luna.Fields.prop_mirror","text":"prop_mirror(Eω, ω, args...; kwargs...)\nprop_mirror(Eω, grid, args...; kwargs...)\n\nReturn a copy of the field Eω after reflection off of mirrors. For other arguments see prop_mirror!\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_mode!","page":"Fields.jl","title":"Luna.Fields.prop_mode!","text":"prop_mode!(Eω, ω, mode, distance, λ0=nothing)\n\nPropagate the field Eω linearly by a certain distance in the given mode. If the central wavelength λ0 is given, remove the group delay at this wavelength. Propagation includes both dispersion and loss.\n\n\n\n\n\n","category":"function"},{"location":"modules/Fields.html#Luna.Fields.prop_taylor!-NTuple{4, Any}","page":"Fields.jl","title":"Luna.Fields.prop_taylor!","text":"prop_taylor!(Eω, grid, ϕs, λ0)\nprop_taylor!(Eω, grid::Grid.AbstractGrid, ϕs, λ0)\n\nAdd spectral phase, given as Taylor-expansion coefficients ϕs around central wavelength λ0, to the frequency-domain field Eω. Sampling axis of Eω can be given either as an AbstractGrid or the frequency axis ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.prop_taylor-Tuple{Any, Vararg{Any}}","page":"Fields.jl","title":"Luna.Fields.prop_taylor","text":"prop_taylor(Eω, grid, ϕs, λ0)\nprop_taylor(Eω, grid::Grid.AbstractGrid, ϕs, λ0)\n\nReturn a copy of the frequency-domain field Eω with added spectral phase, given as Taylor-expansion coefficients ϕs around central wavelength λ0. Sampling axis of Eω can be given either as an AbstractGrid or the frequency axis ω.\n\n\n\n\n\n","category":"method"},{"location":"modules/Fields.html#Luna.Fields.propagator_material-Tuple{Any}","page":"Fields.jl","title":"Luna.Fields.propagator_material","text":"propagator_material(material; P=1, T=PhysData.roomtemp, lookup=nothing)\n\nCreate a function prop!(Eω, ω, thickness, λ0) which propagates the field Eω through a certain thickness of a material. If the central wavelength λ0 is given, remove the group delay at this wavelength.  Keyword arguments P (pressure), T (temperature) and lookup (whether to use lookup table instead of Sellmeier expansion).\n\n\n\n\n\n","category":"method"},{"location":"modules/Grid.html#Grid.jl","page":"Grid.jl","title":"Grid.jl","text":"","category":"section"},{"location":"modules/Grid.html#Luna.Grid.EnvGrid-NTuple{4, Any}","page":"Grid.jl","title":"Luna.Grid.EnvGrid","text":"EnvGrid(zmax, referenceλ, λ_lims, trange; δt=1, thg=false)\n\nTime grid for simulations with envelope (a.k.a. analytic) fields\n\nArguments\n\nzmax::Real : Total distance to propagate\nreferenceλ::Real : Reference wavelength (e.g. centre wavelength of input pulse)\nλ_lims::Tuple{Real, Real} : Wavelength limits of the frequency window\ntrange::Real : Total extent of the time window required\nδt::Real : Sample spacing in time. The value actually used is either δt or the value   required to satisfy trange and λ_lims, whichever is smaller.\nthg::Bool : Whether the grid should include space for the third hamonic (default: false)\n\n\n\n\n\n","category":"method"},{"location":"modules/Grid.html#Luna.Grid.FreeGrid-NTuple{4, Any}","page":"Grid.jl","title":"Luna.Grid.FreeGrid","text":"FreeGrid(Rx, Nx, Ry, Ny; window_factor=0.1)\n\nSpatial grid for full 3D freespace propagation with x/y half-width Rx/Ry and Nx/Ny samples. window_factor determines by how much the grid size is extended to fit a filtering window.\n\n\n\n\n\n","category":"method"},{"location":"modules/Grid.html#Luna.Grid.RealGrid","page":"Grid.jl","title":"Luna.Grid.RealGrid","text":"RealGrid(zmax, referenceλ, λ_lims, trange; δt=1)\n\nTime grid for simulations with real-valued (field-resolved) fields\n\nArguments\n\nzmax::Real : Total distance to propagate\nreferenceλ::Real : Reference wavelength (e.g. centre wavelength of input pulse)\nλ_lims::Tuple{Real, Real} : Wavelength limits of the frequency window\ntrange::Real : Total extent of the time window required\nδt::Real : Sample spacing in time. The value actually used is either δt or the value   required to satisfy trange and λ_lims, whichever is smaller.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Scans.jl","page":"Scans.jl","title":"Scans.jl","text":"","category":"section"},{"location":"modules/Scans.html#Luna.Scans.AbstractExec","page":"Scans.jl","title":"Luna.Scans.AbstractExec","text":"AbstractExec\n\nAbstract supertype for scan execution modes.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.BatchExec","page":"Scans.jl","title":"Luna.Scans.BatchExec","text":"BatchExec(Nbatches, batch)\n\nExecution mode to divide the scan into Nbatches chunks and run only the given batch.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.CondorExec","page":"Scans.jl","title":"Luna.Scans.CondorExec","text":"CondorExec(scriptfile, ncores)\n\nExecution mode which submits a scan to an HTCondor queue system claiming ncores cores.\n\nnote: Note\nscriptfile must always be @__FILE__\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.LocalExec","page":"Scans.jl","title":"Luna.Scans.LocalExec","text":"LocalExec\n\nExecution mode to simply run the whole scan in the current Julia session in a for loop.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.QueueExec","page":"Scans.jl","title":"Luna.Scans.QueueExec","text":"QueueExec(nproc=0, queuefile=\"\")\n\nExecution mode to run a scan using a file-based queueing system. Can be run in multiple separate Julia sessions, or can spawn nproc subprocesses which then take items from the queue to run.\n\nPossible values for nproc are:\n\n0: run only in the current Julia process\nn > 0: spawn n subprocesses and run on these\n-1: spawn as many subprocesses as the number of logical cores on the CPU   (Base.Sys.CPU_THREADS)\n\nIf queuefile is given, the queuefile is stored at that path. If omitted, the queuefile is  stored in Utils.cachedir(). Note that the queuefile is deleted at the end of the scan.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.RangeExec","page":"Scans.jl","title":"Luna.Scans.RangeExec","text":"RangeExec(range)\n\nExecution mode to run a subsection of the scan, given by a UnitRange, in the current Julia session.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.SSHExec","page":"Scans.jl","title":"Luna.Scans.SSHExec","text":"SSHExec(localexec, scriptfile, hostname, subdir)\n\nExecution mode which transfers the scriptfile file to the host given by hostname via SSH and executes the scan on that host with a mode defined by localexec. subdir gives the subdirectory (relative to the home directory) where scans are stored on the remote host. A subfolder with automatically chosen name will be created in subdir to store this scan.\n\nnote: Note\nscriptfile must always be @__FILE__\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.Scan","page":"Scans.jl","title":"Luna.Scans.Scan","text":"Scan(name; kwargs...)\nScan(name, ex::AbstractExec; kwargs...)\n\nCreate a new Scan with name name and variables given as keyword arguments. The execution mode ex can be given directly or via command-line arguments to the script. If given, command-line arguments overwrite any explicitly passed execution mode.\n\nIf neither an explicit execution mode nor command-line arguments are given, ex defaults to LocalExec, i.e. running the whole scan locally in the current Julia process.\n\n\n\n\n\n","category":"type"},{"location":"modules/Scans.html#Luna.Scans.addvariable!-Tuple{Any, Symbol, Any}","page":"Scans.jl","title":"Luna.Scans.addvariable!","text":"addvariable!(scan, variable::Symbol, array)\naddvariable!(scan; kwargs...)\n\nAdd scan variable(s) to the scan, either as a single pair of Symbol and array, or as a  sequence of keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"modules/Scans.html#Luna.Scans.chunks-Tuple{AbstractArray, Int64}","page":"Scans.jl","title":"Luna.Scans.chunks","text":"chunks(a::AbstractArray, n::Int)\n\nSplit array a into n chunks, spreading the entries of a evenly.\n\nExamples\n\njulia> a = collect(range(1, length=10));\njulia> Scans.chunks(a, 3)\n3-element Array{Array{Int64,1},1}:\n [1, 4, 7, 10]\n [2, 5, 8]\n [3, 6, 9]\n\n\n\n\n\n","category":"method"},{"location":"modules/Scans.html#Luna.Scans.makefilename-Tuple{Luna.Scans.Scan, Any}","page":"Scans.jl","title":"Luna.Scans.makefilename","text":"makefilename(scan, scanidx)\n\nMake an appropriate file name for an HDF5Output or prop_capillary output for the scan at the current scanidx.\n\nExamples\n\nscan = Scan(\"scan_example\"; energy=collect(range(5e-6, 200e-6; length=64)))\nrunscan(scan) do scanidx, energyi\n    prop_capillary(125e-6, 3, :He, 0.8; λ0=800e-9, τfwhm=10e-15, energy=energyi\n                   filepath=makefilename(scan, scanidx))\nend\n\n\n\n\n\n","category":"method"},{"location":"modules/Scans.html#Luna.Scans.runscan-Tuple{Any, Luna.Scans.Scan{Luna.Scans.LocalExec}}","page":"Scans.jl","title":"Luna.Scans.runscan","text":"runscan(f, scan)\n\nRun the function f in a scan with arguments defined by the scan::Scan. The function f must have the signature f(scanidx, args...) where the length of args is the number of variables to be scanned over. Can be used with the do block syntax.\n\nThe exact subset and order of scan points which is run depends on scan.exec, see Scan.\n\nExamples\n\nscan = Scan(\"scan_example\"; energy=collect(range(5e-6, 200e-6; length=64)))\nrunscan(scan) do scanidx, energyi\n    prop_capillary(125e-6, 3, :He, 0.8; λ0=800e-9, τfwhm=10e-15, energy=energyi)\nend\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Capillary.jl","page":"Capillary.jl","title":"Capillary.jl","text":"","category":"section"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode\n\nType representing a mode of a hollow capillary as presented in:\n\nMarcatili, E. & Schmeltzer, R. \"Hollow metallic and dielectric waveguides for long distance optical transmission and lasers (Long distance optical transmission in hollow dielectric and metal circular waveguides, examining normal mode propagation).\" Bell System Technical Journal 43, 1783–1809 (1964).\n\n\n\n\n\n","category":"type"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode-NTuple{4, Any}","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode(a, gas, P, cladn; kwargs...)\n\nCreate a MarcatiliMode for a capillary made of a cladding material defined by the refractive index cladn(ω; z) with a core radius a which is filled with gas to pressure P.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode-NTuple{7, Any}","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode(a, n, m, kind, ϕ, coren, cladn; model=:full, loss=true)\n\nCreate a MarcatiliMode.\n\nArguments\n\na : Either a Number for constant core radius, or a function a(z) for variable radius.\nn::Int : Azimuthal mode index (number of nodes in the field along azimuthal angle).\nm::Int : Radial mode index (number of nodes in the field along radial coordinate).\nkind::Symbol : :TE for transverse electric, :TM for transverse magnetic,                  :HE for hybrid mode.\nϕ::Float : Azimuthal offset angle (for linearly polarised modes, this is the angle               between the mode polarisation and the :y axis)\ncoren : Callable coren(ω; z) which returns the refractive index of the core\ncladn : Callable cladn(ω; z) which returns the refractive index of the cladding\nmodel::Symbol=:full : If :full, use the complete Marcatili model which takes into                         account the dispersive influence of the cladding refractive index.                         If :reduced, use the simplified model common in the literature\nloss::Bool=true : Whether to include loss.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode-Tuple{Any, Any, Any}","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode(a, gas, P; kwargs...)\n\nCreate a MarcatiliMode for a capillary with radius a which is filled with gas to pressure P.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode-Tuple{Any, Any}","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode(a, coren; kwargs...)\n\nCreate a MarcatiliMode for a capillary with radius a with z-dependent gas fill determined by coren(ω; z).\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.MarcatiliMode-Tuple{Any}","page":"Capillary.jl","title":"Luna.Capillary.MarcatiliMode","text":"MarcatiliMode(a; kwargs...)\n\nCreate a MarcatiliMode for a capillary with radius a and no gas fill.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.gradient-NTuple{4, Any}","page":"Capillary.jl","title":"Luna.Capillary.gradient","text":"gradient(gas, L, p0, p1)\n\nConvenience function to create density and core index profiles for simple two-point gradient fills defined by the waveguide length L and the pressures at z=0 and z=L.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.gradient-Tuple{Any, Any, Any}","page":"Capillary.jl","title":"Luna.Capillary.gradient","text":"gradient(gas, Z, P)\n\nConvenience function to create density and core index profiles for multi-point gradient fills defined by positions Z and pressures P.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Capillary.transmission-Tuple{Any, Any, Any}","page":"Capillary.jl","title":"Luna.Capillary.transmission","text":"transmission(a, λ, L; kind=:HE, n=1, m=1)\n\nCalculate the transmission through a capillary with core radius a and length L at the wavelength λ when propagating the MarcatiliMode defined by kind, n and m.\n\n\n\n\n\n","category":"method"},{"location":"modules/Capillary.html#Luna.Modes.neff-Tuple{Luna.Capillary.MarcatiliMode, Any}","page":"Capillary.jl","title":"Luna.Modes.neff","text":"neff(m::MarcatiliMode, ω; z=0)\n\nCalculate the complex effective index of Marcatili mode with dielectric core and arbitrary (metal or dielectric) cladding.\n\nAdapted from:\n\nMarcatili, E. & Schmeltzer, R. \"Hollow metallic and dielectric waveguides for long distance optical transmission and lasers (Long distance optical transmission in hollow dielectric and metal circular waveguides, examining normal mode propagation).\" Bell System Technical Journal 43, 1783–1809 (1964).\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Processing.jl","page":"Processing.jl","title":"Processing.jl","text":"","category":"section"},{"location":"modules/Processing.html#Luna.Processing.AutoWindow","page":"Processing.jl","title":"Luna.Processing.AutoWindow","text":"AutoWindow(width, λmin, λmax, ω0fun; relative=false, ndims=1)\n\nWindow function generator which automatically tracks the central frequency in the spectral region given by λmin and λmax and applies a window of a specific width around the peak. The central frequency is found using the function ω0fun(ω, Iω::AbstractVector), where ω and Iω are already cropped to within the wavelength limits given. If relative is true, width is relative bandwidth instead of the wavelength width. ndims determines how many dimensions of the array to sum over. For a field array with size (Nω, N1, N2, ...), the first dimension is always assumed to be frequency. ndim=1 means each field to be analysed is 1-dimensional, so the window iterates over all of (N1, N2, ...). ndim=2 means each field to be analysed is 2-dimensional, (Nω, N1) in size, and will be  summed over its second dimension before finding the central frequency. The window iterates over all other dimensions, (N2, ...).\n\nA AutoWindow automatically stores the limits of the windows it applies in the field lims.\n\n\n\n\n\n","category":"type"},{"location":"modules/Processing.html#Luna.Processing.Common","page":"Processing.jl","title":"Luna.Processing.Common","text":"Common(val)\n\nWrapper type to tell scanproc that val is the same for each simulation being processed, and so only needs to be returned once rather than for each simulation in the scan.\n\n\n\n\n\n","category":"type"},{"location":"modules/Processing.html#Luna.Processing.VarLength","page":"Processing.jl","title":"Luna.Processing.VarLength","text":"VarLength(val)\n\nWrapper type to tell scanproc that the shape of val is different for each simulation being processed. Return values wrapped in VarLength will be placed in an array of arrays.\n\nnote: Note\nWhile the shape of val can be different between simulations, the type must be the same, including the dimensionality and element type of arrays.\n\n\n\n\n\n","category":"type"},{"location":"modules/Processing.html#Luna.Processing.CentroidWindow-Tuple{Any, Any, Any}","page":"Processing.jl","title":"Luna.Processing.CentroidWindow","text":"CentroidWindow(width, λmin, λmax; relative=false, ndims=1, power=1)\n\nAn AutoWindow which uses the centroid (centre of mass or first moment) of the spectral energy density as the central frequency. Before calculating the centroid, the  SED is raised to the power given.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.PeakWindow-Tuple{Any, Any, Any}","page":"Processing.jl","title":"Luna.Processing.PeakWindow","text":"PeakWindow(width, λmin, λmax; relative=false, ndims=1)\n\nAn AutoWindow which uses the peak of the spectral energy density as the central frequency. \n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing._specres_kernel!-NTuple{9, Any}","page":"Processing.jl","title":"Luna.Processing._specres_kernel!","text":"Convolution kernel for each output point. We simply loop over all outer indices and output points. The inner loop adds up the contributions from the specified window around the target point. Note that this works without scaling also for wavelength ranges because the integral is still over a frequency grid (with appropriate frequency dependent integration bounds).\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.arrivaltime-Tuple{Luna.Grid.AbstractGrid, Any}","page":"Processing.jl","title":"Luna.Processing.arrivaltime","text":"arrivaltime(grid, Eω; bandpass=nothing, method=:moment, oversampling=1)\n\nExtract the arrival time of the pulse in the wavelength limits λlims.\n\nArguments\n\nbandpass : method to bandpass the field if required. See window_maybe\nmethod::Symbol : :moment to use 1st moment to extract arrival time, :peak to use                   the time of peak power\noversampling::Int : If >1, oversample the time-domain field before extracting delay\nsumdims : Single Int or Tuple of Ints. The time-domain power will be summed over           these dimensions (e.g. modes) before extracting the arrival time.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.beam-NTuple{4, Any}","page":"Processing.jl","title":"Luna.Processing.beam","text":"beam(grid, Eωm, modes, x, y; z=0, components=:xy)\nbeam(output, x, y, zslice; bandpass=nothing)\n\nCalculate the beam profile of the multi-mode field Eωm on the grid given by spatial coordinates x and y. If output is given, create the modes from that and take the field nearest propagation slice zslice.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.coherence-Tuple{Any}","page":"Processing.jl","title":"Luna.Processing.coherence","text":"coherence(Eω; ndim=1)\n\nCalculate the first-order coherence function g₁₂ of the set of fields Eω. The ensemble average is taken over the last ndim dimensions of Eω, other dimensions are preserved.\n\nSee J. M. Dudley and S. Coen, Optics Letters 27, 1180 (2002).\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.coherence_time-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.coherence_time","text":"coherence_time(grid, Et; dims=1)\n\nGet the coherence time of a field Et over grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.energy-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.energy","text":"energy(grid, Eω; bandpass=nothing)\nenergy(output; bandpass=nothing)\n\nExtract energy. If bandpass is given, bandpass the field according to window_maybe.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.envelope-Tuple{Luna.Grid.RealGrid, Any}","page":"Processing.jl","title":"Luna.Processing.envelope","text":"envelope(grid, Eω)\n\nGet the envelope electric field including the carrier wave from the frequency-domain field Eω sampled on grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.field_autocorrelation-Tuple{Any, Luna.Grid.EnvGrid}","page":"Processing.jl","title":"Luna.Processing.field_autocorrelation","text":"field_autocorrelation(Et; dims=1)\n\nCalculate the field autocorrelation of Et.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.fwhm_f-Tuple{Luna.Grid.AbstractGrid, Any}","page":"Processing.jl","title":"Luna.Processing.fwhm_f","text":"fwhm_f(grid, Eω::Vector; bandpass=nothing, oversampling=1, sumdims=nothing, minmax=:min)\n\nExtract the frequency FWHM. If bandpass is given, bandpass the field according to window_maybe. If sumdims is given, the energy density is summed over these dimensions (e.g. modes) before extracting the FWHM. minmax determines determines whether the FWHM is taken at the narrowest (:min) or the widest (:max) point.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.fwhm_t-Tuple{Luna.Grid.AbstractGrid, Any}","page":"Processing.jl","title":"Luna.Processing.fwhm_t","text":"fwhm_t(grid::AbstractGrid, Eω; bandpass=nothing, oversampling=1, sumdims=nothing, minmax=:min)\n\nExtract the temporal FWHM. If bandpass is given, bandpass the fieldaccording to window_maybe. If oversampling > 1, the  time-domain field is oversampled before extracting the FWHM. If sumdims is given, the time-domain power is summed over these dimensions (e.g. modes) before extracting the FWHM. minmax determines determines whether the FWHM is taken at the narrowest (:min) or the widest (:max) point.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getEt-Tuple{Luna.Grid.AbstractGrid, AbstractArray}","page":"Processing.jl","title":"Luna.Processing.getEt","text":"getEt(grid, Eω; trange=nothing, oversampling=4, bandpass=nothing, FTL=false)\n\nGet the envelope time-domain electric field (including the carrier wave) from the frequency- domain field Eω. The field can be cropped in time using trange, it is oversampled by a factor of oversampling (default 4) and can be bandpassed with bandpass (see window_maybe). If FTL is true, return the Fourier-transform limited pulse, i.e. remove any spectral phase.\n\nIf zslice is given, returs only the slices of Eω closest to the given distances. zslice can be a single number or an array.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getEt-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}","page":"Processing.jl","title":"Luna.Processing.getEt","text":"getEt(output[, zslice]; kwargs...)\n\nGet the envelope time-domain electric field (including the carrier wave) from the output. If zslice is given, returs only the slices of Eω closest to the given distances. zslice can be a single number or an array.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getEtxy-Tuple{Any, Any, Any}","page":"Processing.jl","title":"Luna.Processing.getEtxy","text":"getEtxy(output, xs, z; kwargs...)\ngetEtxy(Etm, modes, xs, z; components=:xy)\n\nCalculate the time-dependent electric field at transverse position xs and longitudinal position z from either the modal time-dependent field Etm or the given output.\n\nxs should be a 2-Tuple of coordinates–either (r, θ) for polar coordinates or (x, y) in Cartesian coordinates, depending on the coordinate system of the modes–or a 2-Tuple of vectors containing the coordinates. If vectors are given, the output contains values of Etxy at all combinations of the coordinates.\n\nAdditional keyword arguments to getEtxy(output, ...) are passed through to Processing.getEt\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getEω-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}","page":"Processing.jl","title":"Luna.Processing.getEω","text":"getEω(output[, zslice])\n\nGet frequency-domain modal field from output with correct normalisation (i.e.  abs2.(Eω)` gives angular-frequency spectral energy density in J/(rad/s)).\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getIω-Tuple{Any, Any, Any}","page":"Processing.jl","title":"Luna.Processing.getIω","text":"getIω(ω, Eω, specaxis; specrange=nothing, resolution=nothing)\n\nGet spectral energy density and x-axis given a frequency array ω and frequency-domain field Eω, assumed to be correctly normalised (see getEω). specaxis determines the x-axis:\n\n:f -> x-axis is frequency in Hz and Iω is in J/Hz\n:ω -> x-axis is angular frequency in rad/s and Iω is in J/(rad/s)\n:λ -> x-axis is wavelength in m and Iω is in J/m\n\nKeyword arguments\n\nspecrange::Tuple can be set to a pair of limits on the spectral range (in specaxis units).\nresolution::Real is set, smooth the spectral energy density as defined by specres.\n\nNote that if resolution and specaxis=:λ is set it is highly recommended to also set specrange.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.getIω-Tuple{Luna.Output.AbstractOutput, Any}","page":"Processing.jl","title":"Luna.Processing.getIω","text":"getIω(output, specaxis[, zslice]; kwargs...)\n\nCalculate the correctly normalised frequency-domain field and convert it to spectral energy density on x-axis specaxis (:f, :ω, or :λ). If zslice is given, returs only the slices of Eω closest to the given distances. zslice can be a single number or an array. specaxis determines the x-axis:\n\n:f -> x-axis is frequency in Hz and Iω is in J/Hz\n:ω -> x-axis is angular frequency in rad/s and Iω is in J/(rad/s)\n:λ -> x-axis is wavelength in m and Iω is in J/m\n\nKeyword arguments\n\nspecrange::Tuple can be set to a pair of limits on the spectral range (in specaxis units).\nresolution::Real is set, smooth the spectral energy density as defined by specres.\n\nNote that resolution is set and specaxis=:λ it is highly recommended to also set specrange.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.intensity_autocorrelation-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.intensity_autocorrelation","text":"intensity_autocorrelation(Et, grid)\n\nCalculate the intensity autocorrelation of Et over grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.ionisation_fraction-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.ionisation_fraction","text":"ionisation_fraction(output, xs; ratefun, oversampling=1)\nionisation_fraction(output; ratefun, oversampling=1, maxevals=1000)\n\nCalculate the ionisation fraction at transverse coordinates xs using the ionisation-rate function ratefun. If xs is not given, calculate the average ionisation fraction across the waveguide core. In this case, maxevals determines the maximum number of function evaluations for the integral.\n\nwarning: Warning\nCalculating the average ionisation fraction is much slower than calculating it at a single point\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.makegrid-Tuple{Any}","page":"Processing.jl","title":"Luna.Processing.makegrid","text":"makegrid(output)\n\nCreate an AbstractGrid from the \"grid\" dictionary saved in output.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.makemodes-Tuple{Any}","page":"Processing.jl","title":"Luna.Processing.makemodes","text":"makemodes(output)\n\nCreate the modes used in a simulation using MarcatiliModes. If output was created by Interface.prop_capillary_args and hence has a field prop_capillary_args, this is used to match the gas fill from the simulation. Otherwise, the modes are created without gas fill.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.nearest_z-Tuple{Any, Number}","page":"Processing.jl","title":"Luna.Processing.nearest_z","text":"nearest_z(output, z)\n\nReturn the index of saved z-position(s) closest to the position(s) z. Output is always an array, even if z is a number. If z is negative, its absolute value is taken as the fraction of the total propagation distance.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.peakpower-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.peakpower","text":"peakpower(grid, Eω; bandpass=nothing, oversampling=1, sumdims=nothing)\npeakpower(output; bandpass=nothing, oversampling=1, sumdims=nothing)\n\nExtract the peak power. If bandpass is given, bandpass the field according to window_maybe. If sumdims is not nothing, sum the time-dependent power over these dimensions (e.g. modes) before taking the maximum.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.scanproc-Tuple{Any, AbstractVector{<:AbstractString}}","page":"Processing.jl","title":"Luna.Processing.scanproc","text":"scanproc(f, scanfiles)\nscanproc(f, directory)\nscanproc(f, directory, pattern)\nscanproc(f)\n\nIterate over the scan output files, apply the processing function f(o::AbstractOutput), and collect the results in arrays.\n\nThe files can be given as:\n\na Vector of AbstractStrings containing file paths\na directory to search for files according to the naming pattern of   Output.ScanHDF5Output\na directory and a glob pattern\n\nIf nothing is specified, scanproc uses the current working directory.\n\nf can return a single value, an array, or a tuple/array of arrays/numbers. Arrays returned by f must either be of the same size for each processed file, or wrapped in a VarLength. Values returned by f which are guaranteed to be identical for each processed file can be wrapped in a Common, and scanproc only returns these once.\n\nExample\n\nEt, Eω = scanproc(\"path/to/scandir\") do output\n    t, Et = getEt(output)\n    ω, Eω = getEω(output)\n    energyout = energyout = Processing.VarLength(output[\"stats\"][\"energy\"])\n    Common(t), Et, Common(ω), Eω, energyout\nend\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.scanproc-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.scanproc","text":"scanproc(f, outputs; shape=nothing)\n\nIterate over the scan outputs, apply the processing function f(o::AbstractOutput), and collect the results in arrays.\n\nIf the outputs are MemoryOutputs which do not contain the scan metadata, the shape of the scan must be given explicitly (e.g. via size(scan)).\n\nf can return a single value, an array, or a tuple/array of arrays/numbers. Arrays returned by f must either be of the same size for each processed output, or wrapped in a VarLength. Values returned by f which are guaranteed to be identical for each processed output can be wrapped in a Common, and scanproc only returns these once.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.specres-NTuple{5, Any}","page":"Processing.jl","title":"Luna.Processing.specres","text":"specres(ω, Iω, specaxis, resolution, specrange; window=nothing, nsamples=10)\n\nSmooth the spectral energy density Iω(ω) to account for the given resolution on the defined specaxis and specrange. The window function to use defaults to a Gaussian function with FWHM of resolution, and by default we sample nsamples=10 times within each resolution.\n\nNote that you should prefer the resolution keyword of getIω instead of calling this function directly.\n\nThe input ω and Iω should be as returned by getIω with specaxis = :ω.\n\nReturns the new specaxis grid and smoothed spectrum.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.time_bandwidth-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.time_bandwidth","text":"time_bandwidth(grid, Eω; bandpass=nothing, oversampling=1)\n\nExtract the time-bandwidth product, after bandpassing if required. The TBP is defined here as ΔfΔt where Δx is the FWHM of x. (In this definition, the TBP of  a perfect Gaussian pulse is ≈0.44). If oversampling > 1, the time-domain field is oversampled before extracting the FWHM.\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}","page":"Processing.jl","title":"Luna.Processing.window_maybe","text":"window_maybe(ω, Eω, win)\n\nApply a frequency window to the field Eω if required. Possible values for win:\n\nnothing : no window is applied\n4-Tuple of Numbers : the 4 parameters for a Maths.planck_taper in wavelength\n3-Tuple of Numbers : minimum, maximum wavelength, and smoothing in radial frequency\n2-Tuple of Numbers : minimum and maximum wavelength with automatically chosen smoothing\nVector{<:Real} : a pre-defined window function (shape must match ω)\nPeakWindow : automatically track the peak in a given range and apply the window around it\nwindow(ω, Eω) : an arbitrary user-supplied window function\n\n\n\n\n\n","category":"method"},{"location":"modules/Processing.html#Luna.Processing.ωwindow_λ-Tuple{Any, Any}","page":"Processing.jl","title":"Luna.Processing.ωwindow_λ","text":"ωwindow_λ(ω, λlims; winwidth=:auto)\n\nCreate a ω-axis filtering window to filter in λlims. winwidth, if a Number, sets the smoothing width of the window in rad/s.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#The-simple-interface","page":"The simple interface","title":"The simple interface","text":"","category":"section"},{"location":"interface.html#Luna.Interface.prop_capillary-Tuple","page":"The simple interface","title":"Luna.Interface.prop_capillary","text":"prop_capillary(radius, flength, gas, pressure; λ0, λlims, trange, kwargs...)\n\nSimulate pulse propagation in a hollow fibre using the capillary model.\n\nMandatory arguments\n\nradius: Core radius of the fibre. Can be a Number for constant radius, or a function   a(z) which returns the z-dependent radius.\nflength::Number: Length of the fibre.\ngas::Symbol: Filling gas species.\npressure: Gas pressure. Can be a Number for constant pressure, a 2-Tuple of Numbers   for a simple pressure gradient, or a Tuple of (Z, P) where Z and P   contain z positions and the pressures at those positions.\nλ0: (keyword argument) the reference wavelength for the simulation. For simple   single-pulse inputs, this is also the central wavelength of the input pulse.\nλlims::Tuple{<:Number, <:Number}: The wavelength limits for the simulation grid.\ntrange::Number: The total width of the time grid. To make the number of samples a   power of 2, the actual grid used is usually bigger.\n\nGrid options\n\nenvelope::Bool: Whether to use envelope fields for the simulation. Defaults to false.   By default, envelope simulations ignore third-harmonic generation.   Plasma has not yet been implemented for envelope fields.\nδt::Number: Time step on the fine grid used for the nonlinear interaction. By default,   this is determined by the wavelength grid. If δt is given and smaller than the   required value, it is used instead.\n\nInput pulse options\n\nA single pulse in the lowest-order mode can be specified by the keyword arguments below. More complex inputs can be defined by a single AbstractPulse or a Vector{AbstractPulse}. In this case, all keyword arguments except for λ0 are ignored.\n\nλ0: Central wavelength\nτfwhm: The pulse duration as defined by the full width at half maximum.\nτw: The \"natural\" pulse duration. Only available if pulseshape is sech.\nϕ: Spectral phases to be applied to the transform-limited pulse. Elements are   the usual polynomial phases ϕ₀ (CEP), ϕ₁ (group delay), ϕ₂ (GDD), ϕ₃ (TOD), etc.\nenergy: Pulse energy.\npower: Peak power after any spectral phases are added.\npulseshape: Shape of the transform-limited pulse. Can be :gauss for a Gaussian pulse   or :sech for a sech² pulse.\npolarisation: Polarisation of the input pulse. Can be :linear (default), :x, :y,   :circular, or an ellipticity number -1 ≤ ε ≤ 1, where ε=-1 corresponds to left-hand circular,   ε=1 to right-hand circular, and ε=0 to linear polarisation. The major axis for   elliptical polarisation is always the y-axis.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\nshotnoise:  If true (default), one-photon-per-mode quantum noise is included.\n\nModes options\n\nmodes: Defines which modes are included in the propagation. Can be any of:\na single mode signifier (default: :HE11), which leads to mode-averaged propagation   (as long as all inputs are linearly polarised).\na list of mode signifiers, which leads to multi-mode propagation in those modes.\na Number N of modes, which simply creates the first N HE modes.\nNote that when elliptical or circular polarisation is included, each mode is present   twice in the output, once for x and once for y polarisation.\nmodel::Symbol: Can be :full, which includes the full complex refractive index of the cladding   in the effective index of the mode, or :reduced, which uses the simpler model more   commonly seen in the literature. See Luna.Capillary for more details.   Defaults to :full.\nloss::Bool: Whether to include propagation loss. Defaults to true.\n\nNonlinear interaction options\n\nkerr: Whether to include the Kerr effect. Defaults to true.\nraman: Whether to include the Raman effect. Defaults to false.\nplasma: Can be one of\n:ADK – include plasma using the ADK ionisation rate.\n:PPT – include plasma using the PPT ionisation rate.\ntrue (default) – same as :PPT.\nfalse – ignore plasma.\nNote that plasma is only available for full-field simulations.\nPPT_stark_shift::Bool: when using the PPT ionisation rate, determines whether   to include the effect of the Stark shift of the ground-state energy levels.   The necessary data is only available for helium, neon, and argon!\nthg::Bool: Whether to include third-harmonic generation. Defaults to true for   full-field simulations and to false for envelope simulations.\n\nIf raman is true, then the following options apply:     - rotation::Bool = true: whether to include the rotational Raman contribution     - vibration::Bool = true: whether to include the vibrational Raman contribution\n\nOutput options\n\nsaveN::Integer: Number of points along z at which to save the field.\nfilepath: If nothing (default), create a MemoryOutput to store the simulation results   only in the working memory. If not nothing, should be a file path as a String,   and the results are saved in a file at this location. If scan is passed, filepath   determines the output directory for the scan instead.\nscan: A Scan instance defining a parameter scan. If scan is given, aOutput.ScanHDF5Outputis used to automatically name and populate output files of   the scan.scanidx` must also be given.\nscanidx: Current scan index within a scan being run. Only used when scan is passed.\nfilename: Can be used to to overwrite the scan name when running a parameter scan.   The running scanidx will be appended to this filename. Ignored if no scan is given.\nstatus_period::Number: Interval (in seconds) between printed status updates.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.prop_capillary_args-NTuple{4, Any}","page":"The simple interface","title":"Luna.Interface.prop_capillary_args","text":"prop_capillary_args(radius, flength, gas, pressure; λ0, λlims, trange, kwargs...)\n\nPrepare to simulate pulse propagation in a hollow fibre using the capillary model. This function takes the same arguments as prop_capillary but instead or running the simulation and returning the output, it returns the required arguments for Luna.run, which is useful for repeated simulations in an indentical fibre with different initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.prop_gnlse-Tuple","page":"The simple interface","title":"Luna.Interface.prop_gnlse","text":"prop_gnlse(γ, flength, βs; λ0, λlims, trange, kwargs...)\n\nSimulate pulse propagation using the GNLSE.\n\nMandatory arguments\n\nγ::Number: The nonlinear coefficient.\nflength::Number: Length of the fibre.\nβs: The Taylor expansion of the propagation constant about λ0.\nλ0: (keyword argument) the reference wavelength for the simulation. For simple   single-pulse inputs, this is also the central wavelength of the input pulse.\nλlims::Tuple{<:Number, <:Number}: The wavelength limits for the simulation grid.\ntrange::Number: The total width of the time grid. To make the number of samples a   power of 2, the actual grid used is usually bigger.\n\nGrid options\n\nδt::Number: Time step on the fine grid used for the nonlinear interaction. By default,   this is determined by the wavelength grid. If δt is given and smaller than the   required value, it is used instead.\n\nInput pulse options\n\nA single pulse can be specified by the keyword arguments below. More complex inputs can be defined by a single AbstractPulse or a Vector{AbstractPulse}. In this case, all keyword arguments except for λ0 are ignored. Note that the current GNLSE model is single mode only.\n\nλ0: Central wavelength\nτfwhm: The pulse duration as defined by the full width at half maximum.\nτw: The \"natural\" pulse duration. Only available if pulseshape is sech.\nϕ: Spectral phases to be applied to the transform-limited pulse. Elements are   the usual polynomial phases ϕ₀ (CEP), ϕ₁ (group delay), ϕ₂ (GDD), ϕ₃ (TOD), etc.\nenergy: Pulse energy.\npower: Peak power after any spectral phases are added.\npulseshape: Shape of the transform-limited pulse. Can be :gauss for a Gaussian pulse   or :sech for a sech² pulse.\npolarisation: Polarisation of the input pulse. Can be :linear (default), :circular,   or an ellipticity number -1 ≤ ε ≤ 1, where ε=-1 corresponds to left-hand circular,   ε=1 to right-hand circular, and ε=0 to linear polarisation. The major axis for   elliptical polarisation is always the y-axis.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\nshotnoise:  If true (default), one-photon-per-mode quantum noise is included.\n\nGNLSE options\n\nshock::Bool: Whether to include the shock derivative term. Default is true.\nraman::Bool: Whether to include the Raman effect. Defaults to true.\nramanmodel; which Raman model to use, defaults to :sdo which uses a simple  damped oscillator model, defined τ1 and τ2 (which default to values commonly  used for silica). ramanmodel can also be set to :SiO2 which uses the more  advanced model of Hollenbeck and Cantrell.\nloss: the power loss [dB/m]. Defaults to 0.\nfr: fractional Raman contribution to γ. Defaults to fr = 0.18.\nτ1: the Raman oscillator period.\nτ2: the Raman damping time.\n\nOutput options\n\nsaveN::Integer: Number of points along z at which to save the field.\nfilepath: If nothing (default), create a MemoryOutput to store the simulation results   only in the working memory. If not nothing, should be a file path as a String,   and the results are saved in a file at this location. If scan is passed, filepath   determines the output directory for the scan instead.\nscan: A Scan instance defining a parameter scan. If scan is given, aOutput.ScanHDF5Outputis used to automatically name and populate output files of   the scan.scanidx` must also be given.\nscanidx: Current scan index within a scan being run. Only used when scan is passed.\nfilename: Can be used to to overwrite the scan name when running a parameter scan.   The running scanidx will be appended to this filename. Ignored if no scan is given.\nstatus_period::Number: Interval (in seconds) between printed status updates.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.prop_gnlse_args-Tuple{Any, Any, Any}","page":"The simple interface","title":"Luna.Interface.prop_gnlse_args","text":"prop_gnlse_args(γ, flength, βs; λ0, λlims, trange, kwargs...)\n\nPrepare to simulate pulse propagation using the GNLSE. This function takes the same arguments as prop_gnlse but instead or running the simulation and returning the output, it returns the required arguments for Luna.run, which is useful for repeated simulations in an indentical fibre with different initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Pulse-types-for-input-to-prop_capillary","page":"The simple interface","title":"Pulse types for input to prop_capillary","text":"","category":"section"},{"location":"interface.html#Luna.Interface.Pulses.CustomPulse-Tuple{}","page":"The simple interface","title":"Luna.Interface.Pulses.CustomPulse","text":"CustomPulse(;λ0, energy=nothing, power=nothing, ϕ=Float64[],\n            mode=:lowest, polarisation=:linear, propagator=nothing)\n\nA custom pulse defined by a function for use with prop_capillary, with either energy or peak power specified.\n\nKeyword arguments\n\nλ0::Number: the central wavelength\nItshape::function: a function I(t)which defines the intensity/power envelope of the                      pulse as a function of timet. Note that the normalisation of this                      envelope is irrelevant as it will be re-scaled byenergyorpower`.\nenergy::Number: the pulse energy.\npower::Number: the pulse peak power (after applying any spectral phases).\nϕ::Vector{Number}: spectral phases (CEP, group delay, GDD, TOD, ...).\nmode::Symbol: Mode in which this input should be coupled. Can be :lowest for the                 lowest-order mode in the simulation, or a mode designation                 (e.g. :HE11, :HE12, :TM01, etc.). Defaults to :lowest.\npolarisation: Can be :linear, :x, :y, :circular, or an ellipticity number -1 ≤ ε ≤ 1,                 where ε=-1 corresponds to left-hand circular, ε=1 to right-hand circular,                 and ε=0 to linear polarisation.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.Pulses.DataPulse-Tuple{AbstractVector, Any, Any}","page":"The simple interface","title":"Luna.Interface.Pulses.DataPulse","text":"DataPulse(ω, Iω, ϕω; energy, λ0=NaN, mode=:lowest, polarisation=:linear, propagator=nothing)\nDataPulse(ω, Eω; energy, λ0=NaN, mode=:lowest, polarisation=:linear, propagator=nothing)\nDataPulse(fpath; energy, λ0=NaN, mode=:lowest, polarisation=:linear, propagator=nothing)\n\nA custom pulse defined by tabulated data to be used with prop_capillary.\n\nData input options\n\nω, Iω, ϕω: arrays of angular frequency ω (units rad/s), spectral energy density Iω              and spectral phase ϕω. ϕω should be unwrapped.\nω, Eω: arrays of angular frequency ω (units rad/s) and the complex frequency-domain          field Eω.\nfpath: a string containing the path to a file which contains 3 columns:   Column 1: frequency (units of Hertz)   Column 2: spectral energy density   Column 3: spectral phase (unwrapped)\n\nKeyword arguments\n\nenergy::Number: the pulse energy\nλ0::Number: the central wavelength (optional; defaults to the centre of mass of the               given spectral energy density).\nϕ::Vector{Number}: spectral phases (CEP, group delay, GDD, TOD, ...) to be applied to the                      pulse (in addition to any phase already present in the data).\nmode::Symbol: Mode in which this input should be coupled. Can be :lowest for the                 lowest-order mode in the simulation, or a mode designation                 (e.g. :HE11, :HE12, :TM01, etc.). Defaults to :lowest.\npolarisation: Can be :linear, :x, :y, :circular, or an ellipticity number -1 ≤ ε ≤ 1,                 where ε=-1 corresponds to left-hand circular, ε=1 to right-hand circular,                 and ε=0 to linear polarisation.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.Pulses.GaussBeamPulse-Tuple{Any, Any}","page":"The simple interface","title":"Luna.Interface.Pulses.GaussBeamPulse","text":"GaussBeamPulse(waist, timepulse)\n\nA pulse whose shape in time is defined by the timepulse::AbstractPulse, and whose modal content is calculated by considering the overlap of an ideal Gaussian laser beam with 1/e² radius waist with the modes of the waveguide.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.Pulses.GaussPulse-Tuple{}","page":"The simple interface","title":"Luna.Interface.Pulses.GaussPulse","text":"GaussPulse(;λ0, τfwhm, energy=nothing, power=nothing, ϕ=Float64[], m=1,\n           mode=:lowest, polarisation=:linear, propagator=nothing)\n\nA (super)Gaussian pulse for use with prop_capillary, with either energy or peak power specified.\n\nKeyword arguments\n\nλ0::Number: the central wavelength.\nτfwhm::Number: the pulse duration (power/intensity FWHM).\nenergy::Number: the pulse energy.\npower::Number: the pulse peak power (after applying any spectral phases).\nϕ::Vector{Number}: spectral phases (CEP, group delay, GDD, TOD, ...).\nm::Int: super-Gaussian parameter (the power in the Gaussian exponent is 2m).           Defaults to 1.\nmode::Symbol: Mode in which this input should be coupled. Can be :lowest for the                 lowest-order mode in the simulation, or a mode designation                 (e.g. :HE11, :HE12, :TM01, etc.). Defaults to :lowest.\npolarisation: Can be :linear, :x, :y, :circular, or an ellipticity number -1 ≤ ε ≤ 1,                 where ε=-1 corresponds to left-hand circular, ε=1 to right-hand circular,                 and ε=0 to linear polarisation.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.Pulses.SechPulse-Tuple{}","page":"The simple interface","title":"Luna.Interface.Pulses.SechPulse","text":"SechPulse(;λ0, τfwhm=nothing, τw=nothing, energy=nothing, power=nothing, ϕ=Float64[],\n           mode=:lowest, polarisation=:linear, propagator=nothing)\n\nA sech²(τ/τw) pulse for use with prop_capillary, with either energy or peak power specified, and duration given either as τfwhm or τw.\n\nKeyword arguments\n\nλ0::Number: the central wavelength.\nτfwhm::Number: the pulse duration (power/intensity FWHM).\nτw::Number: \"natural\" pulse duration of a sech²(τ/τw) pulse.\nenergy::Number: the pulse energy.\npower::Number: the pulse peak power (after applying any spectral phases).\nϕ::Vector{Number}: spectral phases (CEP, group delay, GDD, TOD, ...)\nmode::Symbol: Mode in which this input should be coupled. Can be :lowest for the                 lowest-order mode in the simulation, or a mode designation                 (e.g. :HE11, :HE12, :TM01, etc.). Defaults to :lowest.\npolarisation: Can be :linear, :x, :y, :circular, or an ellipticity number -1 ≤ ε ≤ 1,                 where ε=-1 corresponds to left-hand circular, ε=1 to right-hand circular,                 and ε=0 to linear polarisation.\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Luna.Interface.Pulses.LunaPulse-Tuple{Luna.Output.AbstractOutput}","page":"The simple interface","title":"Luna.Interface.Pulses.LunaPulse","text":"LunaPulse(output; energy, λ0=NaN, mode=:lowest, polarisation=:linear, propagator=nothing)\n\nA pulse defined to be used with prop_capillary which comes from a previous Luna propagation simulation.\n\nFor multi-mode simulations, only the lowest-order modes is transferred.\n\nArguments\n\noutput::AbstractOutput: output from a previous Luna simulation.\n\nKeyword arguments\n\nenergy::Number: the pulse energy. When transferring multi-mode simulations this defines the total energy.\nscale_energy: if given instead of energy, scale the field from output by this number. Defaults to 1, so giving energy is not required. For multi-mode simulations, this can also be a Vector with the same number of elements as the number of modes, in which case the energy of each mode is scaled by the corresponding number.\nλ0::Number: the central wavelength (optional; defaults to the centre of mass of the               given spectral energy density).\nϕ::Vector{Number}: spectral phases (CEP, group delay, GDD, TOD, ...) to be applied to the                      pulse (in addition to any phase already present in the data).\npropagator: A function propagator!(Eω, grid) which mutates its first argument to               apply an arbitrary propagation to the pulse before the simulation starts.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Stats.jl","page":"Stats.jl","title":"Stats.jl","text":"","category":"section"},{"location":"modules/Stats.html#Luna.Stats.collect_stats-Tuple{Any, Any, Vararg{Any}}","page":"Stats.jl","title":"Luna.Stats.collect_stats","text":"collect_stats(grid, Eω, funcs...)\n\nCreate a closure which collects statistics from the individual functions in funcs.\n\nEach function given will be called with the arguments (d, Eω, Et, z, dz), where\n\nd -> dictionary to store statistics values. each func should mutate this\nEω -> frequency-domain field\nEt -> analytic time-domain field\nz -> current propagation distance\ndz -> current stepsize\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.copyto_fft!-Tuple{Any, Any, Any}","page":"Stats.jl","title":"Luna.Stats.copyto_fft!","text":"copyto_fft!(Eωa, Eω, idxhi)\n\nCopy the rFFT-sampled field Eω to the FFT-sampled buffer Eωa, ready for inverse FFT\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.core_radius-Tuple{Number}","page":"Stats.jl","title":"Luna.Stats.core_radius","text":"core_radius(a)\n\nCreate stats function to capture core radius as defined by a (either a Number or a  callable a(z))\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.density-Tuple{Any}","page":"Stats.jl","title":"Luna.Stats.density","text":"density(dfun)\n\nCreate stats function to capture the gas density as defined by dfun(z)\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.electrondensity-Tuple{Luna.Grid.RealGrid, Any, Any, Any}","page":"Stats.jl","title":"Luna.Stats.electrondensity","text":"electrondensity(grid, ionrate, dfun, aeff; oversampling=1)\n\nCreate stats function to calculate the maximum electron density in mode average.\n\nIf oversampling > 1, the field is oversampled before the calculation\n\nwarning: Warning\nOversampling can lead to a significant performance hit\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.electrondensity-Tuple{Luna.Grid.RealGrid, Any, Any, Union{Tuple{Vararg{Luna.Modes.AbstractMode}}, AbstractArray{T} where T<:Luna.Modes.AbstractMode}}","page":"Stats.jl","title":"Luna.Stats.electrondensity","text":"electrondensity(grid, ionrate, dfun, modes; oversampling=1)\n\nCreate stats function to calculate the maximum electron density for multimode simulations.\n\nIf oversampling > 1, the field is oversampled before the calculation\n\nwarning: Warning\nOversampling can lead to a significant performance hit\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.energy-Tuple{Any, Any}","page":"Stats.jl","title":"Luna.Stats.energy","text":"energy(grid, energyfun_ω)\n\nCreate stats function to calculate the total energy.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.energy_window-Tuple{Any, Any, Any}","page":"Stats.jl","title":"Luna.Stats.energy_window","text":"energy_window(grid, energyfun_ω, window; label)\n\nCreate stats function to calculate the energy filtered by a window. The stats dataset will be named energy_[label].\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.energy_λ-Tuple{Any, Any, Any}","page":"Stats.jl","title":"Luna.Stats.energy_λ","text":"energy_λ(grid, energyfun_ω, λlims; label)\n\nCreate stats function to calculate the energy in a wavelength region given by λlims. If label is omitted, the stats dataset is named by the wavelength limits.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.fwhm_r-Tuple{Any, Any}","page":"Stats.jl","title":"Luna.Stats.fwhm_r","text":"fwhm_r(grid, modes; components=:y)\n\nCreate stats function to calculate the radial FWHM (aka beam size) in a modal propagation.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.fwhm_t-Tuple{Any}","page":"Stats.jl","title":"Luna.Stats.fwhm_t","text":"fwhm_t(grid)\n\nCreate stats function to calculate the temporal FWHM (pulse duration) for mode average.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.peakintensity-Tuple{Any, Any}","page":"Stats.jl","title":"Luna.Stats.peakintensity","text":"peakintensity(grid, aeff)\n\nCreate stats function to calculate the mode-averaged peak intensity given the effective area aeff(z).\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.peakintensity-Tuple{Any, Union{Tuple{Vararg{Luna.Modes.AbstractMode}}, AbstractArray{T} where T<:Luna.Modes.AbstractMode}}","page":"Stats.jl","title":"Luna.Stats.peakintensity","text":"peakintensity(grid, mode)\n\nCreate stats function to calculate the peak intensity for several modes.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.peakpower-Tuple{Any, Any, Tuple{var\"#s981\", var\"#s981\"} where var\"#s981\"<:Real}","page":"Stats.jl","title":"Luna.Stats.peakpower","text":"peakpower(grid, Eω, λlims; label=nothing)\n\nCreate stats function to calculate the peak power within a frequency range defined by the wavelength limits λlims. If label is given, the stats dataset is labeled as peakpower_[label], otherwise label is created automatically from λlims.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.peakpower-Tuple{Any, Any, Vector{<:Real}}","page":"Stats.jl","title":"Luna.Stats.peakpower","text":"peakpower(grid, Eω, window; label)\n\nCreate stats function to calculate the peak power within a frequency range defined by the window function window. window must have the same length as grid.ω. The stats dataset is labeled as peakpower_[label].\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.peakpower-Tuple{Any}","page":"Stats.jl","title":"Luna.Stats.peakpower","text":"peakpower(grid)\n\nCreate stats function to calculate the peak power.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.plan_analytic-Tuple{Luna.Grid.EnvGrid, Any}","page":"Stats.jl","title":"Luna.Stats.plan_analytic","text":"plan_analytic(grid, Eω)\n\nPlan a transform from the frequency-domain field Eω to the analytic time-domain field.\n\nReturns both a buffer for the analytic field and a closure to do the transform.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.pressure-Tuple{Any, Any}","page":"Stats.jl","title":"Luna.Stats.pressure","text":"pressure(dfun, gas)\n\nCreate stats function to capture the pressure. Like density but converts to pressure.\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.zdw-Tuple{Any}","page":"Stats.jl","title":"Luna.Stats.zdw","text":"zdw(mode)\n\nCreate stats function to capture the zero-dispersion wavelength (ZDW).\n\nwarning: Warning\nSince Modes.zdw is based on root-finding of a derivative, this can be slow!\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.zdw-Tuple{Luna.Modes.AbstractMode}","page":"Stats.jl","title":"Luna.Stats.zdw","text":"zdw(mode)\n\nCreate stats function to capture the zero-dispersion wavelength (ZDW).\n\nwarning: Warning\nSince Modes.zdw is based on root-finding of a derivative, this can be slow!\n\n\n\n\n\n","category":"method"},{"location":"modules/Stats.html#Luna.Stats.ω0-Tuple{Any}","page":"Stats.jl","title":"Luna.Stats.ω0","text":"ω0(grid)\n\nCreate stats function to calculate the centre of mass (first moment) of the spectral power density.\n\n\n\n\n\n","category":"method"},{"location":"model/model.html#The-numerical-model","page":"General description","title":"The numerical model","text":"","category":"section"},{"location":"model/model.html","page":"General description","title":"General description","text":"Pages = [\"model.md\", \"modal_decompositions.md\", \"nonlinear_responses.md\"]\nDepth = 2","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"Luna can solve several different variations of the unidirectional pulse propagation equation (UPPE). All of these variations have this basic form in common:","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"partial_z E(omega mathbfk_perp z)mathrmdz = mathcalL(omega mathbfk_perp z)E(omega mathbfk_perp z) + fraciomegaN_mathrmnl P_mathrmnl(omega mathbfk_perp z)","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"where E(omega mathbfk_perp z) is the electric field in \"reciprocal space\", i.e. frequency and transverse spatial frequency, omega is angular frequency, mathbfk_perp is some generalised transverse spatial frequency, z is the propagation direction, mathcalL(omega mathbfk_perp z) is a linear operator describing dispersion, loss and diffraction, P_mathrmnl(omega mathbfk_perp z) is the nonlinear polarisation induced by the field E(omega mathbfk_perp z), and N_mathrmnl is a normalisation factor. Since calculating the nonlinear polarisation directly in the frequency domain is not feasible, this is done in the real-space-time domain instead, and P_mathrmnl(omega mathbfk_perp z) is obtained by transforming back:","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"P_mathrmnl(omega mathbfk_perp z) = int_-infty^infty mathcalT_perpBigmathcalP_mathrmnl(E(t mathbfr_perp z)Big(t mathbfk_perp z)mathrme^iomega tmathrmdt","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"where mathcalT_perp is a transform from (transverse) real space to reciprocal space (i.e. spatial frequency), mathbfr_perp is the transverse spatial coordinate, t is time, and  mathcalP is an operator which calculates the nonlinear response of the medium given an electric field. Naturally, the real-space field E(t mathbfr_perp z) first has to be obtained from E(omega mathbfk_perp z):","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"E(t mathbfr_perp z)  = int_-infty^infty mathrmdomega mathcalT_perp^-1BigE(omega mathbfk_perp z)Bigmathrme^-iomega t","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"where mathcalT_perp^-1 is simply the inverse of mathcalT_perp so transforms from transverse reciprocal space to real space. The chief difference between variations of the UPPE implemented in Luna is the definition of mathbfk_perp and mathcalT_perp, that is, the choice of Modal decompositions of the field.","category":"page"},{"location":"model/model.html#A-note-on-sign-conventions","page":"General description","title":"A note on sign conventions","text":"","category":"section"},{"location":"model/model.html","page":"General description","title":"General description","text":"In optics, a plane wave is usually written as","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"E(t mathbfr) = mathrme^i(mathbfkcdotmathbfr - omega t)","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"and hence a general field, the superposition of many plane waves, is","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"E(t mathbfr) = int_-infty^infty tildeE(omega mathbfk)mathrme^i(mathbfkcdotmathbfr - omega t)mathrmdomegamathrmd^3mathbfk","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"which means that for the time-domain Fourier transform, the sign convention is opposite to that used in mathematics, with the forward and inverse transforms given by","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"tildeE(omega) = mathcalF_tleftE(t)right = int_-infty^infty  E(t)mathrme^iomega tmathrmd t \n\n\nE(t) = mathcalF^-1_omegaleftE(omega)right = frac12piint_-infty^infty E(omega)mathrme^-iomega tmathrmd omega ","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"In this convention with one sign in the exponent for space and the opposite for time, positive group-velocity dispersion (GVD) is indeed a positive parabola (12beta_2(omega-omega_0)^2 with positive beta_2), waves with positive wave vectors move to larger mathbfr for larger times t and so forth. However, fast Fourier transforms (FFTs) use the mathematics convention. For complex (envelope) fields, this could be circumvented by simply using ifft instead of fft and vice versa, but this is not possible for real-valued fields using real FFTs (rFFT). The sign conventions in Luna are:","category":"page"},{"location":"model/model.html","page":"General description","title":"General description","text":"All physical expressions and quantities (propagation constants, dispersion, nonlinear phases etc.) are given in the optics convention, i.e. as they would be found in a textbook.\nThe fields in the actual simulation are given in the mathematics convention as required for FFTs. This leads to the appearance in additional minus signs in the linear operator, see e.g. make_const_linop. Similarly, to add e.g. some dispersion to a field used in or returned by a Luna simulation, the sign of that dispersion has to be flipped.","category":"page"},{"location":"modules/RectModes.html#RectModes.jl","page":"RectModes.jl","title":"RectModes.jl","text":"","category":"section"},{"location":"modules/RectModes.html#Luna.RectModes.RectMode-NTuple{4, Any}","page":"RectModes.jl","title":"Luna.RectModes.RectMode","text":"convenience constructor for non-constant core index\n\n\n\n\n\n","category":"method"},{"location":"modules/RectModes.html#Luna.RectModes.RectMode-NTuple{5, Any}","page":"RectModes.jl","title":"Luna.RectModes.RectMode","text":"convenience constructor assunming single gas filling and specified cladding\n\n\n\n\n\n","category":"method"},{"location":"modules/RectModes.html#Luna.Modes.neff-Tuple{Luna.RectModes.RectMode, Any}","page":"RectModes.jl","title":"Luna.Modes.neff","text":"neff(m::RectMode, ω; z=0)\n\neffective index of rectangular mode with dielectric core and arbitrary  (metal or dielectric) cladding.\n\nAdapted from Laakmann, K. D. & Steier, W. H. Waveguides: characteristic modes of hollow rectangular dielectric waveguides. Appl. Opt., AO 15, 1334–1340 (1976).\n\nI had to re-derive the result in order to get the complex cladding index contribution to the real part of neff.\n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Raman.jl","page":"Raman.jl","title":"Raman.jl","text":"","category":"section"},{"location":"modules/Raman.html#Luna.Raman.AbstractRamanResponse-Tuple{Any, Any}","page":"Raman.jl","title":"Luna.Raman.AbstractRamanResponse","text":"(R::AbstractRamanResponse)(t, ρ)\n\nGet the full response function at time t and density ̢ρ.\n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Luna.Raman.RamanRespIntermediateBroadening","page":"Raman.jl","title":"Luna.Raman.RamanRespIntermediateBroadening","text":"RamanRespIntermediateBroadening(ωi, Ai, Γi, γi, scale)\n\nConstruct an intermediate broadened model with component positions ωi [rad/s], amplitudes Ai, Gaussian widths Γi [rad/s] and Lorentzian widths γi [rad/s]. The overall response is scaled by scale. Based on Hollenbeck and Cantrell, \"Multiple-vibrational-mode model for fiber-optic Raman gain spectrum and response function\", J. Opt. Soc. Am. B/Vol. 19, No. 12/December 2002.\n\n\n\n\n\n","category":"type"},{"location":"modules/Raman.html#Luna.Raman.RamanRespRotationalNonRigid-Tuple{Any, Any, Int64, Int64}","page":"Raman.jl","title":"Luna.Raman.RamanRespRotationalNonRigid","text":"RamanRespRotationalNonRigid(B, Δα, τ2, qJodd, qJeven;\n                            D=0.0, minJ=0, maxJ=50, temp=roomtemp,\n                            τ2=nothing, Bρ=nothing, Aρ=nothing)\n\nConstruct a rotational nonrigid rotor Raman model.\n\nArguments\n\nB::Real: the rotational constant [1/m]\nΔα::Real: molecular polarizability anisotropy [m^3]\nqJodd::Integer: nuclear spin parameter for odd J\nqJeven::Integer: nuclear spin parameter for even J\nD::Real=0.0: centrifugal constant [1/m]\nminJ::Integer=0: J value to start at\nmaxJ::Integer=50: J value to sum until\ntemp::Real=roomtemp: temperature\nτ2::Real=nothing: coherence time [s]\nBρ::Real=nothing : density dependent broadening coefficient [Hz/amagat]\nAρ::Real=nothing : self diffusion coefficient [Hz amagat]\n\nOnly one of τ2 or Bρ should be specified. If Bρ is specified then Aρ must be too.\n\nReferences\n\nFull model description: Laser & Photonics Reviews, 16, p. 2100426, (2022) doi: 10.1002/lpor.202100426.\nWe followed closely: Phys. Rev. A, vol. 92, no. 6, p. 063828, Dec. 2015, But note that that paper uses weird units, and we converted it to SI for the above reference. \n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Luna.Raman.RamanRespNormedSingleDampedOscillator-Tuple{Any, Any, Any}","page":"Raman.jl","title":"Luna.Raman.RamanRespNormedSingleDampedOscillator","text":"RamanRespNormedSingleDampedOscillator(K, Ω, τ2)\n\nConstruct a simple normalised single damped oscillator model with scale factor K, angular frequency Ω and density independent coherence time τ2.\n\nThe scale factor K is applied after normalising the integral of the response function to unity.\n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Luna.Raman.RamanRespVibrational-Tuple{Any, Any, Any}","page":"Raman.jl","title":"Luna.Raman.RamanRespVibrational","text":"RamanRespVibrational(Ωv, dαdQ, μ; τ2=nothing, Bρ=nothing, Aρ=nothing)\n\nConstruct a molecular vibrational Raman model (single damped oscillator).\n\nArguments\n\nΩv::Real: vibrational frequency [rad/s]\ndαdQ::Real: isotropic averaged polarizability derivative [m^2]\nμ::Real: reduced molecular mass [kg]\nτ2::Real=nothing: coherence time [s]\nBρ::Real=nothing : density dependent broadening coefficient [Hz/amagat]\nAρ::Real=nothing : self diffusion coefficient [Hz amagat]\nC::Real=0 : constant linewidth [Hz]\n\nOnly one of τ2 or Bρ should be specified. If Bρ is specified then Aρ must be too.\n\nReferences\n\nFull model description:   S-.F. Gao, Y-Y. Wang, F. Belli, C. Brahms, P. Wang and J.C. Travers,   Laser & Photonics Reviews 16, 2100426 (2022)\nWe followed closely:   Phys. Rev. A, vol. 92, no. 6, p. 063828, Dec. 2015,   But note that that paper uses weird units, and we converted it to SI for   the above reference. \n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Luna.Raman.hrdamp","page":"Raman.jl","title":"Luna.Raman.hrdamp","text":"hrdamp(R::AbstractRamanResponse, ρ)\n\nGet the damping (dephasing) constant τ2 for density ̢ρ.\n\n\n\n\n\n","category":"function"},{"location":"modules/Raman.html#Luna.Raman.hrpre","page":"Raman.jl","title":"Luna.Raman.hrpre","text":"hrpre(R::AbstractRamanResponse, t)\n\nGet the pre (without damping) response function at time t.\n\n\n\n\n\n","category":"function"},{"location":"modules/Raman.html#Luna.Raman.molecular_raman_response-Tuple{Any, Any}","page":"Raman.jl","title":"Luna.Raman.molecular_raman_response","text":"molecular_raman_response(rp; kwargs...)\n\nGet the Raman response function for the Raman parameters in named tuple rp.\n\nKeyword Arguments\n\nrotation::Bool = true: whether to include the rotational contribution\nvibration::Bool = true: whether to include the vibrational contribution\nminJ::Integer = 0: the minimum rotational quantum number to include\nmaxJ::Integer = 50: the maximum rotational quantum number to include\ntemp::Real = roomtemp: the temperature\n\n\n\n\n\n","category":"method"},{"location":"modules/Raman.html#Luna.Raman.raman_response","page":"Raman.jl","title":"Luna.Raman.raman_response","text":"raman_response(t, material; kwargs...)\n\nGet the Raman response function for time grid t and the material.\n\nFor details on the keyword arguments see molecular_raman_response.\n\n\n\n\n\n","category":"function"},{"location":"modules/NonlinearRHS.html#NonlinearRHS.jl","page":"NonlinearRHS.jl","title":"NonlinearRHS.jl","text":"","category":"section"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransFree-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransFree","text":"(t::TransFree)(nl, Eω, z)\n\nCalculate the reciprocal-domain (ω-kx-ky-space) nonlinear response due to the field Eω and place the result in nl.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransFree-Tuple{Luna.Grid.RealGrid, Vararg{Any}}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransFree","text":"TransFree(grid, xygrid, FT, responses, densityfun, normfun)\n\nConstruct a TransFree to calculate the reciprocal-domain nonlinear polarisation.\n\nArguments\n\ngrid::AbstractGrid : the grid used in the simulation\nxygrid : the spatial grid (instances of Grid.FreeGrid)\nFT::FFTW.Plan : the full 3D (t-y-x) Fourier transform for the oversampled time grid\nresponses : Tuple of response functions\ndensityfun : callable which returns the gas density as a function of z\nnormfun : normalisation factor as fctn of z, can be created via norm_free\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransModal","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransModal","text":"TransModal\n\nTransform E(ω) -> Pₙₗ(ω) for modal fields.\n\n\n\n\n\n","category":"type"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransModal-Tuple{Any, Any, Luna.Modes.ToSpace, Vararg{Any, 4}}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransModal","text":"TransModal(grid, ts, FT, resp, densityfun, norm!; rtol=1e-3, atol=0.0, mfcn=300, full=false)\n\nConstruct a TransModal, transform E(ω) -> Pₙₗ(ω) for modal fields.\n\nArguments\n\ngrid::AbstractGrid : the grid used in the simulation\nts::Modes.ToSpace : pre-created ToSpace for conversion from modal fields to space\nFT::FFTW.Plan : the time-frequency Fourier transform for the oversampled time grid\nresp : Tuple of response functions\ndensityfun : callable which returns the gas density as a function of z\nnorm! : normalisation function as fctn of z, can be created via norm_modal\nrtol::Float=1e-3 : relative tolerance on the HCubature integration\natol::Float=0.0 : absolute tolerance on the HCubature integration\nmfcn::Int=300 : maximum number of function evaluations for one modal integration\nfull::Bool=false : if true, use full 2-D mode integral, if false, only do radial integral\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransModeAvg","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransModeAvg","text":"TransModeAvg\n\nTransform E(ω) -> Pₙₗ(ω) for mode-averaged single-mode propagation.\n\n\n\n\n\n","category":"type"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransRadial","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransRadial","text":"TransRadial\n\nTransform E(ω) -> Pₙₗ(ω) for radially symetric free-space propagation\n\n\n\n\n\n","category":"type"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransRadial-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransRadial","text":"(t::TransRadial)(nl, Eω, z)\n\nCalculate the reciprocal-domain (ω-k-space) nonlinear response due to the field Eω and place the result in nl\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.TransRadial-Tuple{Luna.Grid.RealGrid, Vararg{Any}}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.TransRadial","text":"TransRadial(grid, HT, FT, responses, densityfun, normfun)\n\nConstruct a TransRadial to calculate the reciprocal-domain nonlinear polarisation.\n\nArguments\n\ngrid::AbstractGrid : the grid used in the simulation\nHT::QDHT : the Hankel transform which defines the spatial grid\nFT::FFTW.Plan : the time-frequency Fourier transform for the oversampled time grid\nresponses : Tuple of response functions\ndensityfun : callable which returns the gas density as a function of z\nnormfun : normalisation factor as fctn of z, can be created via norm_radial\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.Et_to_Pt!-Tuple{Any, Any, Any, Number}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.Et_to_Pt!","text":"Et_to_Pt!(Pt, Et, responses, density)\n\nAccumulate responses induced by Et in Pt.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.const_norm_free-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.const_norm_free","text":"const_norm_free(grid, xygrid, nfun)\n\nMake function to return normalisation factor for 3D propagation without re-calculating at every step.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.const_norm_radial-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.const_norm_radial","text":"const_norm_radial(ω, q, nfun)\n\nMake function to return normalisation factor for radial symmetry without re-calculating at every step. \n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.copy_scale!-Tuple{Vector, Vector, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.copy_scale!","text":"copy_scale!(dest, source, N, scale)\n\nCopy first N elements from source to dest and simultaneously multiply by scale factor. For multi-dimensional dest and source, work along first axis.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.copy_scale_both!-Tuple{Vector, Vector, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.copy_scale_both!","text":"copy_scale_both!(dest::Vector, source::Vector, N, scale)\n\nCopy first and last N elements from source to first and last N elements in dest and simultaneously multiply by scale factor. For multi-dimensional dest and source, work along first axis.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.norm_free-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.norm_free","text":"norm_free(grid, xygrid, nfun)\n\nMake function to return normalisation factor for 3D propagation.\n\nnote: Note\nHere, nfun(ω; z) needs to take frequency ω and a keyword argument z.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.norm_modal-Tuple{Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.norm_modal","text":"norm_modal(grid; shock=true)\n\nNormalisation function for modal propagation. If shock is false, the intrinsic frequency dependence of the nonlinear response is ignored, which turns off optical shock formation/ self-steepening.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.norm_radial-Tuple{Any, Any, Any}","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.norm_radial","text":"norm_radial(ω, q, nfun)\n\nMake function to return normalisation factor for radial symmetry. \n\nnote: Note\nHere, nfun(ω; z) needs to take frequency ω and a keyword argument z.\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.to_freq!-Union{Tuple{D}, Tuple{Any, Any, Array{<:Real, D}, Any}} where D","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.to_freq!","text":"to_freq!(Aω, Aωo, Ato, FTplan)\n\nTransform oversampled A(t) to A(ω) on normal grid\n\n\n\n\n\n","category":"method"},{"location":"modules/NonlinearRHS.html#Luna.NonlinearRHS.to_time!-Union{Tuple{D}, Tuple{Array{<:Real, D}, Any, Any, Any}} where D","page":"NonlinearRHS.jl","title":"Luna.NonlinearRHS.to_time!","text":"to_time!(Ato, Aω, Aωo, IFTplan)\n\nTransform A(ω) on normal grid to A(t) on oversampled time grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/Antiresonant.html#Antiresonant.jl","page":"Antiresonant.jl","title":"Antiresonant.jl","text":"","category":"section"},{"location":"modules/Antiresonant.html#Luna.Antiresonant.VincettiMode-Tuple{Any, Vararg{Any}}","page":"Antiresonant.jl","title":"Luna.Antiresonant.VincettiMode","text":"VincettiMode(a, args...; wallthickness, tube_radius, Ntubes, cladn, Nterms,\n                         loss=true, kwargs...)\n\nCreate a mode with Marcatili-like mode fields but loss, dispersion and effective area given by the semi-empirical model developed by Vincetti et al. in refs [1-3]. Arguments are identical to Capillary.MarcatiliMode but with the following additions/changes as keyword arguments:\n\nMandatory keyword arguments\n\nwallthickness : wall thickness of the resonators (cladding capillaries)\ntube_radius : radius of the resonators\nNtubes : number of resonators\n\nOptional keyword arguments\n\ncladn : refractive index of the resonators as a function of (ω; z). Defaults           to the refractive index of silica (SiO2).\nNterms : number of resonator dielectric modes to include in the model. Defaults to 8.\nloss : can be true or false to switch loss on/off, or a Real to scale the loss.\n\nTo specify the gap between resonators, calculate the core radius with getRco(r_ext, N, δ) or calculate the external radius of the resonators with getr_ext(Rco, N, δ).\n\nReferences\n\n[1] L. Vincetti Empirical formulas for calculating loss in hollow core tube lattice fibers,  Opt. Express, OE, vol. 24, no. 10, pp. 10313-10325, May 2016, doi: 10.1364/OE.24.010313.\n\n[2] L. Vincetti and L. Rosa A simple analytical model for confinement loss estimation in hollow-core Tube Lattice Fibers Opt. Express, OE, vol. 27, no. 4, pp. 5230-5237, Feb. 2019, doi: 10.1364/OE.27.005230.\n\n[3]L. Rosa, F. Melli, and L. Vincetti Analytical Formulas for Dispersion and Effective Area in Hollow-Core Tube Lattice Fibers Fibers, vol. 9, no. 10, Art. no. 10, Oct. 2021, doi: 10.3390/fib9100058.\n\n\n\n\n\n","category":"method"},{"location":"modules/Antiresonant.html#Luna.Antiresonant.ZeisbergerMode-Tuple","page":"Antiresonant.jl","title":"Luna.Antiresonant.ZeisbergerMode","text":"ZeisbergerMode(args...; wallthickness, kwargs...)\n\nCreate a capillary-like mode with the effective index given by eq. (15) in [1].\n\nwallthickness (mandatory kwarg) sets the thickness of the anti-resonant struts and loss (optional, defaults to true) can be either a Bool (to switch on/off loss completely) or a Real (to up/down-scale the loss given by the model).  Other kwargs are passed on to the constructor of a Capillary.MarcatiliMode.\n\n[1] Zeisberger, M., Schmidt, M.A. Analytic model for the complex effective index of the leaky modes of tube-type anti-resonant hollow core fibers. Sci Rep 7, 11761 (2017). https://doi.org/10.1038/s41598-017-12234-5\n\n\n\n\n\n","category":"method"},{"location":"modules/Antiresonant.html#Luna.Antiresonant.getRco-Tuple{Any, Any, Any}","page":"Antiresonant.jl","title":"Luna.Antiresonant.getRco","text":"getRco(r_ext, N, δ)\n\nCalculate the inscribed core radius of a single-ring antiresonant PCF with N resonators with external radius r_ext and a gap between resonators of δ. \n\n\n\n\n\n","category":"method"},{"location":"modules/Antiresonant.html#Luna.Antiresonant.getr_ext-Tuple{Any, Any, Any}","page":"Antiresonant.jl","title":"Luna.Antiresonant.getr_ext","text":"getr_ext(Rco, N, δ)\n\nCalculate the external radius of the resonators for a single-ring antiresonant PCF with core radius Rco, N resonators and a gap between resonators of δ.\n\n\n\n\n\n","category":"method"},{"location":"modules/Antiresonant.html#Luna.Antiresonant.getδ-Tuple{Any, Any, Any}","page":"Antiresonant.jl","title":"Luna.Antiresonant.getδ","text":"getδ(Rco, r_ext, N)\n\nCalculate the gap between resonators in a single-ring antiresonant PCF with inscribed core radius Rco for N resonators with external radius r_ext.\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Nonlinear.jl","page":"Nonlinear.jl","title":"Nonlinear.jl","text":"","category":"section"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.PlasmaCumtrapz","page":"Nonlinear.jl","title":"Luna.Nonlinear.PlasmaCumtrapz","text":"Response type for cumtrapz-based plasma polarisation, adapted from: M. Geissler, G. Tempea, A. Scrinzi, M. Schnürer, F. Krausz, and T. Brabec, Physical Review Letters 83, 2930 (1999).\n\n\n\n\n\n","category":"type"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.PlasmaCumtrapz-NTuple{4, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.PlasmaCumtrapz","text":"PlasmaCumtrapz(t, E, ratefunc, ionpot)\n\nConstruct the Plasma polarisation response for a field on time grid t with example electric field like E, an ionization rate callable ratefunc and ionization potential ionpot.\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.PlasmaCumtrapz-Tuple{Any, Any, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.PlasmaCumtrapz","text":"Handle plasma polarisation routing to PlasmaVector or PlasmaScalar.\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolar","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolar","text":"Raman polarisation response type\n\n\n\n\n\n","category":"type"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolar-Tuple{Any, Any, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolar","text":"Calculate Raman polarisation for field/envelope Et\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolarEnv","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolarEnv","text":"Raman polarisation response type for an envelope\n\n\n\n\n\n","category":"type"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolarEnv-Tuple{Any, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolarEnv","text":"RamanPolarEnv(t, ht)\n\nConstruct Raman polarisation response for an envelope on time grid t using response function r.\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolarField","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolarField","text":"Raman polarisation response type for a carrier resolved field\n\n\n\n\n\n","category":"type"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.RamanPolarField-Tuple{Any, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.RamanPolarField","text":"RamanPolarField(t, ht; thg=true)\n\nConstruct Raman polarisation response for a field on time grid t using response function r. If thg=false then exclude the third harmonic generation component of the response.\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.Kerr_env-Tuple{Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.Kerr_env","text":"Kerr response for envelope\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.Kerr_field-Tuple{Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.Kerr_field","text":"Kerr response for real field\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.Kerr_field_nothg-Tuple{Any, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.Kerr_field_nothg","text":"Kerr response for real field but without THG\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.PlasmaScalar!-Tuple{Luna.Nonlinear.PlasmaCumtrapz, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.PlasmaScalar!","text":"The plasma response for a scalar electric field\n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.PlasmaVector!-Tuple{Luna.Nonlinear.PlasmaCumtrapz, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.PlasmaVector!","text":"The plasma response for a vector electric field.\n\nWe take the magnitude of the electric field to calculate the ionization rate and fraction, and then solve the plasma polarisation component-wise for the vector field.\n\nA similar approach was used in: C Tailliez et al 2020 New J. Phys. 22 103038.  \n\n\n\n\n\n","category":"method"},{"location":"modules/Nonlinear.html#Luna.Nonlinear.sqr!-Tuple{Luna.Nonlinear.RamanPolarField, Any}","page":"Nonlinear.jl","title":"Luna.Nonlinear.sqr!","text":"Square the field or envelope\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#PhysData.jl","page":"PhysData.jl","title":"PhysData.jl","text":"","category":"section"},{"location":"modules/PhysData.html#Luna.PhysData.N_A","page":"PhysData.jl","title":"Luna.PhysData.N_A","text":"Avogadro constant\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.amg","page":"PhysData.jl","title":"Luna.PhysData.amg","text":"Amagat (Loschmidt constant)\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.atm","page":"PhysData.jl","title":"Luna.PhysData.atm","text":"Pressure in Pascal at standard conditions (atmospheric pressure)\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.au_Efield","page":"PhysData.jl","title":"Luna.PhysData.au_Efield","text":"Atomic unit of electric field\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.au_energy","page":"PhysData.jl","title":"Luna.PhysData.au_energy","text":"Atomic unit of energy\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.au_polarisability","page":"PhysData.jl","title":"Luna.PhysData.au_polarisability","text":"Atomic unit of electric polarisability\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.au_time","page":"PhysData.jl","title":"Luna.PhysData.au_time","text":"Atomic unit of time\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.bar","page":"PhysData.jl","title":"Luna.PhysData.bar","text":"Pressure in Pascal of 1 bar\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.c","page":"PhysData.jl","title":"Luna.PhysData.c","text":"Speed of light\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.e_ratio","page":"PhysData.jl","title":"Luna.PhysData.e_ratio","text":"Ratio of electron charge squared to electron mass (for plasma)\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.electron","page":"PhysData.jl","title":"Luna.PhysData.electron","text":"Electron charge\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.k_B","page":"PhysData.jl","title":"Luna.PhysData.k_B","text":"Boltzmann constant\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.m_e","page":"PhysData.jl","title":"Luna.PhysData.m_e","text":"Electron mass\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.m_u","page":"PhysData.jl","title":"Luna.PhysData.m_u","text":"Atomic mass unit\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.roomtemp","page":"PhysData.jl","title":"Luna.PhysData.roomtemp","text":"Room temperature in Kelvin (ca 20 deg C)\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.ħ","page":"PhysData.jl","title":"Luna.PhysData.ħ","text":"Reduced Planck's constant\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.ε_0","page":"PhysData.jl","title":"Luna.PhysData.ε_0","text":"Permittivity of vacuum\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.μ_0","page":"PhysData.jl","title":"Luna.PhysData.μ_0","text":"Permeability of vacuum\n\n\n\n\n\n","category":"constant"},{"location":"modules/PhysData.html#Luna.PhysData.Cnl_ADK-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.Cnl_ADK","text":"Cnl_ADK(material)\n\nReturn the value of Cₙₗ from the ADK paper for the material. For materialS other than noble gases, this returns missing.\n\nReference: Ammosov, M. V., Delone, N. B. & Krainov, V. P. Tunnel Ionization Of Complex Atoms And Atomic Ions In Electromagnetic Field. Soviet Physics JETP 64, 1191–1194 (1986).\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.data_metal-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.data_metal","text":"Lookup tables for complex refractive indices of metals.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.density","page":"PhysData.jl","title":"Luna.PhysData.density","text":"density(material::Symbol, P=1.0, T=roomtemp)\n\nFor a gas material, return the number density [m^-3] at pressure P [bar] and temperature T [K]. For a glass, this simply returns 1.0.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.densityspline-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.densityspline","text":"densityspline(gas; Pmax, Pmin=0, N=2^10, T=roomtemp)\n\nCreate a CSpline interpolant for the density of the gas between pressures Pmin and Pmax at temperature T. The spline is created using N samples.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.dispersion","page":"PhysData.jl","title":"Luna.PhysData.dispersion","text":"dispersion(order, material, λ, P=1.0, T=roomtemp; lookup=nothing)\n\nCalculate the dispersion of order order of a given material at a wavelength λ.\n\nFor gases the pressure P (default:atmosphere) and the temperature T (default: room temp) can also be specified. lookup::Bool determines whether a lookup table or a Sellmeier  expansion is used for the refractive index (default is material dependent).\n\nExamples\n\njulia> dispersion(2, :BK7, 400e-9) * 1e30 * 1e-3 # convert to fs^2/mm\n122.03632107303108\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.dispersion_func","page":"PhysData.jl","title":"Luna.PhysData.dispersion_func","text":"dispersion_func(order, material, P=1, T=roomtemp; lookup=nothing)\n\nGet a function to calculate dispersion. Arguments are the same as for dispersion.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.dispersion_func-Tuple{Any, Any}","page":"PhysData.jl","title":"Luna.PhysData.dispersion_func","text":"dispersion_func(order, n)\n\nGet a function that calculates dispersion of order order for a refractive index given by n(λ).\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.fresnel-Tuple{Any, Any}","page":"PhysData.jl","title":"Luna.PhysData.fresnel","text":"fresnel(n2, θi; n1=1.0)\n\nCalcualte reflection coefficients from Fresnel's equations.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.ionisation_potential-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.ionisation_potential","text":"ionisation_potential(material; unit=:SI)\n\nReturn the first ionisation potential of the material in a specific unit (default: SI). Possible units are :SI, :atomic and :eV.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.lookup_glass-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.lookup_glass","text":"lookup_glass(material::Symbol)\n\nCreate a CSpline interpolant for look-up-table values of the refractive index.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.lookup_metal-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.lookup_metal","text":"lookup_metal(material::Symbol)\n\nCreate a CSpline interpolant for look-up-table values of the refractive index.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.lookup_mirror-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.lookup_mirror","text":"lookup_mirror(type)\n\nCreate a CSpline interpolant for the complex-valued reflectivity of a mirror of type.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.polarisability_difference-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.polarisability_difference","text":"polarisability_difference(material; unit=:SI)\n\nReturn the difference in polarisability between the ground state and the ion for the material. unit can be :SI or :atomic\n\nReference: Wang, K. et al. Static dipole polarizabilities of atoms and ions from Z=1 to 20 calculated within a single theoretical scheme. Eur. Phys. J. D 75, 46 (2021).\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.pressure","page":"PhysData.jl","title":"Luna.PhysData.pressure","text":"pressure(gas, density, T=roomtemp)\n\nCalculate the pressure in bar of the gas at number density density and temperature T.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.process_mirror_data-NTuple{7, Any}","page":"PhysData.jl","title":"Luna.PhysData.process_mirror_data","text":"process_mirror_data(λR, R, λGDD, GDD, λ0, λmin, λmax; fitorder=5, windowwidth=20e-9)\n\nProcess reflectivity and group-delay dispersion data for a mirror and create a transfer function for a frequency-domain electric field representing the mirror.\n\nArguments:\n\nλR: wavelength samples for reflectivity in SI units (m)\nR: mirror reflectivity (between 0 and 1)\nλGDD: wavelength samples for GDD in SI units (m)\nGDD: GDD in SI units (s²)\nλ0: central wavelength (used to remove any overall group delay)\nλmin, λmax: bounds of the wavelength region to apply the transfer function over\n\nKeyword arguments\n\nfitorder: order of polynomial fit to use in removing overall group delay (default: 5)\nwindowwidth: wavelength width of the smoothing region outside (λmin, λmax)               for the window in SI units (default: 20e-9, i.e. 20 nm)\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.quantum_numbers-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.quantum_numbers","text":"quantum_numbers(material)\n\nReturn the quantum numbers of the material for use in the PPT ionisation rate.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.raman_parameters-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.raman_parameters","text":"raman_parameters(material)\n\nGet the Raman parameters for material.\n\nFields\n\nFields in the returned named tuple must include:\n\nkind::Symbol: one of :molecular or :intermediate or :normedsdo\n\nIf kind == :molecular then the following must also be specified:\n\nrotation::Symbol: only :nonrigid or :none supported at present.\nvibration::Symbol: only :sdo or :none supported at present.\n\nIf rotation == :nonrigid then the following must also be specified:\n\nB::Real: the rotational constant [1/m]\nΔα::Real: molecular polarizability anisotropy [m^3]\nqJodd::Integer: nuclear spin parameter for odd J\nqJeven::Integer: nuclear spin parameter for even J\nD::Real=0.0: centrifugal constant [1/m]\n\nAlong with one of:\n\nτ2r::Real: coherence time [s]\nBρr::Real : density dependent broadening coefficient [Hz/amagat]\n\nIf both τ2r and Bρr are specified, then Bρr takes precedence. If Bρr is specified then we also need:\n\nAρr::Real : self diffusion coefficient [Hz amagat]\n\nIf vibration == :sdo then the following must also be specified:\n\nΩv::Real: vibrational frequency [rad/s]\ndαdQ::Real: isotropic averaged polarizability derivative [m^2]\nμ::Real: reduced molecular mass [kg]\n\nAlong with one of:\n\nτ2v::Real: coherence time [s]\nBρv::Real : density dependent broadening coefficient [Hz/amagat]\n\nIf both τ2v and Bρv are specified, then Bρv takes precedence. If Bρv is specified then we also need:\n\nAρv::Real : self diffusion coefficient [Hz amagat]\n\nAnd can also add (if necessary) a constant offset:\n\nCv::Real : constant linewidth offset [Hz]\n\nIf kind == :intermediate then the following must be specified\n\nωi::Vector{Real} [rad/s], central angular freqencies\nAi::Vector{Real}, amplitudes\nΓi::Vector{Real} [rad/s], Gaussian widths\nγi::Vector{Real} [rad/s], Lorentzian widths\n\nReferences\n\n[1] Phys. Rev. A, 94, 023816 (2016) [2] Phys. Rev. A, 85, 043820 (2012) [3] Phys. Rev. A, 92, 063828 (2015) [4] Journal of Raman Spectroscopy 2, 133 (1974) [5] J. Phys. Chem., 91, 41 (1987) [6] Applied Spectroscopy 23, 211 (1969) [7] Phys. Rev. A, 34, 3, 1944 (1986) [8] Can. J. Phys., 44, 4, 797 (1966) [9] G. V. MIKHAtLOV, SOVIET PHYSICS JETP, vol. 36, no. 9, (1959). [10] Phys. Rev. A, 33, 5, 3113 (1986) [11] IEEE Journal of Quantum Electronics 1986, 22 (2), 332–336. https://doi.org/10.1109/JQE.1986.1072945. [12] Phys. Rev. Lett. 1998, 81 (6), 1215–1218. https://doi.org/10.1103/PhysRevLett.81.1215. [13] Optics Communications 1987, 64 (4), 393–397. https://doi.org/10.1016/0030-4018(87)90258-6. [14] Science Advances 2020, 6 (34), eabb5375. https://doi.org/10.1126/sciadv.abb5375. [15] Long, The Raman Effect; John Wiley & Sons, Ltd, 2002; [16] IEEE Journal of Quantum Electronics, vol. 24, no. 10, pp. 2076–2080, Oct. 1988, doi: 10.1109/3.8545. [17] Journal of Raman Spectroscopy, vol. 22, no. 11, pp. 607–611, 1991, doi: 10.1002/jrs.1250221103. [18] Hollenbeck and Cantrell, JOSA B 19, 2886-2892 (2002). https://doi.org/10.1364/JOSAB.19.002886\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.ref_index","page":"PhysData.jl","title":"Luna.PhysData.ref_index","text":"ref_index(material, λ, P=1.0, T=roomtemp; lookup=nothing)\n\nGet refractive index for any material at wavelength given in SI units.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.ref_index_fun","page":"PhysData.jl","title":"Luna.PhysData.ref_index_fun","text":"ref_index_fun(material::Symbol, P=1.0, T=roomtemp; lookup=nothing)\n\nGet function which returns refractive index.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.ref_index_fun-Union{Tuple{NTuple{N, Symbol}}, Tuple{N}, Tuple{NTuple{N, Symbol}, Any}} where N","page":"PhysData.jl","title":"Luna.PhysData.ref_index_fun","text":"ref_index_fun(gases, T=roomtemp)\n\nGet function which returns ref index for mixture as function of wavelength and densities.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.ref_index_fun-Union{Tuple{N}, Tuple{NTuple{N, Symbol}, NTuple{N, Number}}, Tuple{NTuple{N, Symbol}, NTuple{N, Number}, Any}} where N","page":"PhysData.jl","title":"Luna.PhysData.ref_index_fun","text":"ref_index_fun(gases, P, T=roomtemp; lookup=nothing)\n\nGet function which returns refractive index for gas mixture. gases is a Tuple of gas identifiers (Symbols) and P is a Tuple of equal length containing pressures.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.sellmeier_crystal-Tuple{Any, Any}","page":"PhysData.jl","title":"Luna.PhysData.sellmeier_crystal","text":"sellmeier_crystal(material, axis)\n\nSellmeier for crystals. Returns function of wavelength in μm which in turn returns the refractive index directly. Possible values for axis depend on the type of crystal.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.sellmeier_gas-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.sellmeier_gas","text":"sellmeier_gas(material::Symbol)\n\nReturn function for linear polarisability γ, i.e. susceptibility of a single particle, calculated from Sellmeier expansions.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.sellmeier_glass-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.sellmeier_glass","text":"sellmeier_glass(material::Symbol)\n\nSellmeier for glasses. Returns function of wavelength in μm which in turn returns the refractive index directly\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.wlfreq-Tuple{Any}","page":"PhysData.jl","title":"Luna.PhysData.wlfreq","text":"wlfreq(ωλ)\n\nChange from ω (angular frequency) to λ (wavelength) and vice versa\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.ΔλΔω-Tuple{Any, Any}","page":"PhysData.jl","title":"Luna.PhysData.ΔλΔω","text":"ΔλΔω(Δλ, λ)\n\nConvert Δλ (wavelength bandwidth) at λ (central wavelength) to Δω (angular frequency bandwidth)\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ3_gas-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.γ3_gas","text":"γ3_gas(material::Symbol; source=nothing)\n\nCalculate single-molecule third-order hyperpolarisability of a gas at given wavelength(s) and at room temperature. If source == :Bishop: Uses reference values to calculate γ If source == :Lehmeier (default): Uses scaling factors to calculate χ3 at 1 bar and scales by density to get to a single molecule i.e. the hyperpolarisability\n\nReferences: [1] Journal of Chemical Physics, AIP, 91, 3549-3551 (1989) [2] Chemical Reviews, 94, 3-29 (1994) [3] Optics Communications, 56(1), 67–72 (1985) [4] Phys. Rev. A, vol. 42, 2578 (1990) [5] Optics Letters Vol. 40, No. 24 (2015)) [6] Phys. Rev. A 2012, 85 (4), 043820. https://doi.org/10.1103/PhysRevA.85.043820. [7] Phys. Rev. A, 32, no. 6, 3454, (1985), doi: 10.1103/PhysRevA.32.3454.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ_Börzsönyi-NTuple{4, Any}","page":"PhysData.jl","title":"Luna.PhysData.γ_Börzsönyi","text":"γ_Börzsönyi(B1, C1, B2, C2)\n\nSellmeier expansion for linear susceptibility from Applied Optics 47, 27, 4856 (2008) at room temperature and atmospheric pressure\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ_JCT-NTuple{6, Any}","page":"PhysData.jl","title":"Luna.PhysData.γ_JCT","text":"γ_JCT(B1, C1, B2, C2, B3, C3)\n\nAdapted Sellmeier expansion for helium made to fit high frequency data Phys. Rev. A 92, 033821 (2015)\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ_Peck-NTuple{5, Any}","page":"PhysData.jl","title":"Luna.PhysData.γ_Peck","text":"γ_Peck(B1, C1, B2, C2, dens)\n\nSellmeier expansion for linear susceptibility from J. Opt. Soc. Am. 67, 1550 (1977)\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ_QuanfuHe-NTuple{4, Any}","page":"PhysData.jl","title":"Luna.PhysData.γ_QuanfuHe","text":"γ_QuanfuHe(A, B, C, dens)\n\nSellmeier expansion for CH4, SF6 and N2O from Atmospheric Chemistry and Physics 2021, 21 (19), 14927–14940. https://doi.org/10.5194/acp-21-14927-2021.\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.γ_Zhang-NTuple{4, Any}","page":"PhysData.jl","title":"Luna.PhysData.γ_Zhang","text":"γ_Zhang(A, B, C, dens)\n\nSellmeier expansion for Oxygen from Applied Optics 50, 35, 6484 (2011)\n\n\n\n\n\n","category":"method"},{"location":"modules/PhysData.html#Luna.PhysData.χ1","page":"PhysData.jl","title":"Luna.PhysData.χ1","text":"χ1(gas::Symbol, λ, P=1.0, T=roomtemp)\n\nCalculate χ1 at wavelength λ in SI units, pressure P in bar and temperature T in Kelvin. Gases only.\n\n\n\n\n\n","category":"function"},{"location":"modules/PhysData.html#Luna.PhysData.χ1_fun-Tuple{Symbol}","page":"PhysData.jl","title":"Luna.PhysData.χ1_fun","text":"χ1_fun(gas::Symbol)\n\nGet function to return χ1 (linear susceptibility) for gases as a function of wavelength in SI units, pressure in bar, and temperature in Kelvin.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#LinearOps.jl","page":"LinearOps.jl","title":"LinearOps.jl","text":"","category":"section"},{"location":"modules/LinearOps.html#Luna.LinearOps.conj_clamp-Tuple{Any, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.conj_clamp","text":"conj_clamp(n, ω)\n\nSimultaneously conjugate and clamp the effective index n to safe levels.\n\nThe real part is lower-bounded at 1e-3 and the imaginary part upper-bounded at an attenuation coefficient α of 3000 (130 dB/cm). The limits are somewhat arbitrary and chosen empirically from previous bugs. See https://github.com/LupoLab/Luna/pull/142.\n\nSee also αlim!.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_const_linop-Tuple{Luna.Grid.EnvGrid, Luna.Modes.AbstractMode, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.make_const_linop","text":"make_const_linop(grid, mode, λ0)\n\nMake constant linear operator for mode-averaged propagation in mode mode with a reference wavelength λ0.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_const_linop-Tuple{Luna.Grid.RealGrid, Any, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.make_const_linop","text":"make_const_linop(grid, modes, λ0; ref_mode=1)\n\nMake constant (z-invariant) linear operator for multimode propagation. The frame velocity is taken as the group velocity at wavelength λ0 in the mode given by ref_mode (which  indexes into modes)\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_const_linop-Tuple{Luna.Grid.RealGrid, Hankel.QDHT, AbstractArray, Number}","page":"LinearOps.jl","title":"Luna.LinearOps.make_const_linop","text":"make_const_linop(grid, q::QDHT, n, frame_vel)\n\nMake constant linear operator for radial free-space. n is the refractive index (array) and β1 is 1/velocity of the reference frame.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_const_linop-Tuple{Luna.Grid.RealGrid, Luna.Grid.FreeGrid, AbstractArray, Number}","page":"LinearOps.jl","title":"Luna.LinearOps.make_const_linop","text":"make_const_linop(grid, xygrid, n, frame_vel)\n\nMake constant linear operator for full 3D propagation. n is the refractive index (array) and β1 is 1/velocity of the reference frame.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_linop-Tuple{Luna.Grid.RealGrid, Hankel.QDHT, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.make_linop","text":"make_linop(grid, q::QDHT, nfun)\n\nMake z-dependent linear operator for radial free-space propagation. nfun(ω; z) should return the refractive index as a function of frequency ω and (kwarg) propagation distance z.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.make_linop-Tuple{Luna.Grid.RealGrid, Luna.Grid.FreeGrid, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.make_linop","text":"make_linop(grid, xygrid, nfun)\n\nMake z-dependent linear operator for free-space propagation. nfun(ω; z) should return the refractive index as a function of frequency ω and (kwarg) propagation distance z.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.neff_grid-Tuple{Any, Any, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.neff_grid","text":"neff_grid(grid, modes, λ0; ref_mode=1)\n\nCreate a closure that returns the effective index as a function of the frequency grid and mode index, rather than the mode and frequency themselves. Any Modes.AbstractMode may define its one method for neff_grid to accelerate repeated calculation on the same frequency grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.neff_β_grid-Tuple{Any, Any, Any}","page":"LinearOps.jl","title":"Luna.LinearOps.neff_β_grid","text":"neff_β_grid(grid, mode, λ0; ref_mode=1)\n\nCreate closures which return the effective index and propagation constant as a function of the frequency grid index, rather than the frequency itself. Any Modes.AbstractMode may define its own method for neff_β_grid to accelerate repeated calculation on the same frequency grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/LinearOps.html#Luna.LinearOps.αlim!-Tuple{Any}","page":"LinearOps.jl","title":"Luna.LinearOps.αlim!","text":"αlim!(α)\n\nLimit α so that we do not get overflow in exp(α*dz)\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Ionisation.jl","page":"Ionisation.jl","title":"Ionisation.jl","text":"","category":"section"},{"location":"modules/Ionisation.html#Luna.Ionisation.ADK_threshold-Tuple{Any}","page":"Ionisation.jl","title":"Luna.Ionisation.ADK_threshold","text":"ADK_threshold(ionpot)\n\nDetermine the lowest electric field strength at which the ADK ionisation rate for the ionisation potential ionpot is non-zero to within 64-bit floating-point precision.\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.barrier_suppression-Tuple{Any, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.barrier_suppression","text":"barrier_suppression(ionpot, Z)\n\nCalculate the barrier-suppresion field strength for the ionisation potential ionpot and charge state Z.\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.ionfrac-Tuple{Any, Any, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.ionfrac","text":"ionfrac(rate, E, δt)\n\nGiven an ionisation rate function rate and an electric field array E sampled with time spacing δt, calculate the ionisation fraction as a function of time on the same time axis.\n\nThe function rate should have the signature rate!(out, E) and place its results into out, like the functions returned by e.g. ionrate_fun!_ADK or ionrate_fun!_PPTcached.\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.ionrate_fun!_ADK","page":"Ionisation.jl","title":"Luna.Ionisation.ionrate_fun!_ADK","text":"ionrate_fun!_ADK(ionpot::Float64, threshold=true)\nionrate_fun!_ADK(material::Symbol)\n\nReturn a closure ionrate!(out, E) which calculates the ADK ionisation rate for the electric field E and places the result in out. If threshold is true, use ADK_threshold to avoid calculation below floating-point precision. If cycle_average is true, calculate the cycle-averaged ADK ionisation rate instead.\n\n\n\n\n\n","category":"function"},{"location":"modules/Ionisation.html#Luna.Ionisation.ionrate_fun!_PPTaccel-Tuple{Symbol, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.ionrate_fun!_PPTaccel","text":"ionrate_fun!_PPTaccel(material::Symbol, λ0; kwargs...)\nionrate_fun!_PPTaccel(ionpot::Float64, λ0, Z, l; kwargs...)\n\nCreate an accelerated (interpolated) PPT ionisation rate function.\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.ionrate_fun!_PPTcached-Tuple{Symbol, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.ionrate_fun!_PPTcached","text":"ionrate_fun!_PPTcached(material::Symbol, λ0; kwargs...)\nionrate_fun!_PPTcached(ionpot::Float64, λ0, Z, l; kwargs...)\n\nCreate a cached (saved) interpolated PPT ionisation rate function. If a saved lookup table exists, load this rather than recalculate.\n\nKeyword arguments\n\nN::Int: Number of samples with which to create the CSpline interpolant.\nEmax::Number: Maximum field strength to include in the interpolant.\ncachedir::String: Path to the directory where the cache should be stored and loaded from.   Defaults to HOME/.luna/pptcache\n\nOther keyword arguments are passed on to ionrate_fun_PPT\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.ionrate_fun_PPT-Tuple{Float64, Any, Any, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.ionrate_fun_PPT","text":"ionrate_fun_PPT(ionpot::Float64, λ0, Z, l; kwargs...)\n\nCreate closure to calculate PPT ionisation rate.\n\nKeyword arguments\n\nsum_tol::Number: Relative tolerance used to truncate the infinite sum.\ncycle_average::Bool: If false (default), calculate the cycle-averaged rate\nsum_integral::Bool: whether to approximate the infinite sum in the PPT rate equation with   an integral (this neglects the multiphoton thresholds).\nΔα::Number: polarisability difference between the ground state and the cation (in SI units)   to calculate the Stark shift of the ground-state energy levels. Defaults to 0.\nmsum::Bool: for l ≠ 0, whether or not to sum over different m states. Defaults to true.\nCnl::Real : Pre-calculated Cₙₗ constant. If not given, defaults to the approximate expression from   the PPT papers.\noccupancy: Occupancy of the state(s) from which ionisation is considered. Defaults to 2 for    a state with two electrons (spin up/down).\n\nReferences\n\n[1] Ilkov, F. A., Decker, J. E. & Chin, S. L. Ionization of atoms in the tunnelling regime with experimental evidence using Hg atoms. Journal of Physics B: Atomic, Molecular and Optical Physics 25, 4005–4020 (1992)\n\n[2] Bergé, L., Skupin, S., Nuter, R., Kasparian, J. & Wolf, J.-P. Ultrashort filaments of light in weakly ionized, optically transparent media. Rep. Prog. Phys. 70, 1633–1713 (2007) (Appendix A)\n\n[3] A. Couairon and A. Mysyrowicz, \"Femtosecond filamentation in transparent media,\" Physics Reports 441(2–4), 47–189 (2007).\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.keldysh-Tuple{Any, Any, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.keldysh","text":"keldysh(material, λ, E)\n\nCalculate the Keldysh parameter for the given material at wavelength λ and electric field strength E.\n\n\n\n\n\n","category":"method"},{"location":"modules/Ionisation.html#Luna.Ionisation.φ-Tuple{Any, Any}","page":"Ionisation.jl","title":"Luna.Ionisation.φ","text":"φ(m, x)\n\nCalculate the φ function for the PPT ionisation rate.\n\nNote that wm(x) in [1] and φm(x) in [2] look slightly different but are in fact identical.\n\n\n\n\n\n","category":"method"},{"location":"model/modal_decompositions.html#Modal-decompositions","page":"Modal decompositions","title":"Modal decompositions","text":"","category":"section"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"note: Note\nAll Fourier transforms in this section are written in the optics sign convention. See A note on sign conventions for details on what is used in the code.","category":"page"},{"location":"model/modal_decompositions.html#Multi-mode-guided","page":"Modal decompositions","title":"Multi-mode guided","text":"","category":"section"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"For propagation in waveguides taking into account multiple modes and the coupling between them, Luna uses the model laid out in Kolesik and Moloney, Nonlinear optical pulse propagation simulation: From Maxwell’s to unidirectional equations and Tani et al., Multimode ultrafast nonlinear optics in optical waveguides: numerical modeling and experiments in kagomé photonic-crystal fiber. This is implemented in NonlinearRHS.TransModal. The electric field mathbfE(t mathbfr_perp z) is expressed as the inverse Fourier transform in time and the superposition of waveguide modes in space. This means that the transverse wave vector mathbfk_perp turns into a modal index j (this transform is implemented in Modes.ToSpace and Modes.to_space!):","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"mathbfE(t mathbfr_perp z) = frac12pi int_-infty^infty mathrmd omega sum_j hatmathbfe_j(mathbfr_perp z) tildeA_j(omega z) mathrme^-i omega t","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where hatmathbfe_j(mathbfr_perp z) is the orthonormal transverse field distribution of the j^mathrmth mode and tildeA_j(omega z) is the frequency-domain amplitude in mode j. The mode fields hatmathbfe_j(mathbfr_perp z) are taken to be independent of frequency but can depend on the propagation coordinate z (e.g. in tapered waveguides). They can be vector quantities if polarisations other than purely lineary x- or y-polarisations need to be taken into account. The modes are normalised such that vert tildeA_j(omega z) vert^2 gives the spectral energy density in mode j (when also taking into account the normalisation of the FFT), and equivalently vert A_j(t z)vert^2 gives the instantaneous power. The forward transform to reciprocal space is simply the overlap integral of the total field with each mode combined with the Fourier transform in time:","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"tildeA_j(omega z) = int_S mathrmd^2mathbfr_perp int_-infty^infty mathrmd t hatmathbfe_j^*(mathbfr_perp z) cdot mathbfE(t mathbfr_perp z) mathrme^i omega t","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where S is the cross-sectional area of the waveguide. This transform is implemented in NonlinearRHS.TransModal for use within simulations and in Modes.overlap for decomposition of existing sampled fields. In both cases, the mode overlap integral is solved explicitly with a p-adaptive or h-adaptive cubature method.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"The linear operator for a mode mathcalL_j(omega z) is given by (see LinearOps.make_const_linop)","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"mathcalL_j(omega z) = ileft(beta_j(omega z) - fracomegavright) - frac12alpha_j(omega z)","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where beta_j(omega z) is real-valued and describes the phase evolution of the mode, v is a chosen frame velocity (this is the same for all modes) and alpha(omega z) (also real) describes the attenuation of the waveguide (i.e. 1alpha is the 1mathrme power/energy loss length). This can also be expressed in terms of the effective index of the mode:","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"mathcalL_j(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where c is the speed of light in vacuum and n_mathrmeff is complex, n_mathrmeff = n + i k, with n describing the effective refractive index and k describing the attenuation.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"With the modal power normalisation for hatmathbfe_j(mathbfr_perp z), the normalisation factor N_mathrmnl comes out as simply N_mathrmnl=4. The propagation equation, coupling the modes through the nonlinear polarisation, is therefore","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"partial_z tildeA_j(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)tildeA_j(omega z) + ifracomega4 tildemathbfP_mathrmnl","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where tildemathbfP_mathrmnl is given by","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"tildemathbfP_mathrmnl =  int_S mathrmd^2mathbfr_perp int_-infty^infty mathrmd t hatmathbfe_j^*(mathbfr_perp z) cdot mathbfP_mathrmnlleftmathbfE(t mathbfr_perp z)right mathrme^i omega t","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"and mathbfE(t mathbfr_perp z) is obtained from the set of tildeA_j(omega z) as above.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"The transverse coordinate mathbfr_perp for circular waveguides (e.g. hollow capillaries, optical fibres, and anti-resonant fibres) is in polar coordinates, mathbfr_perp = (r theta). For other waveguides (e.g. rectangular), it is Cartesian, mathbfr_perp = (x y).","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"note: Note\nWhile mathbfr_perp can be given in either coordinate system, the components of the modal fields hatmathbfe_j(mathbfr_perp z) are always given in Cartesian coordinates, i.e. the basis vectors for the polarisation of the field are always mathbfx and mathbfy.","category":"page"},{"location":"model/modal_decompositions.html#Implementation","page":"Modal decompositions","title":"Implementation","text":"","category":"section"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"The modules and functions that define and implement this decomposition for different modes are","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Modes.jl\nCapillary.jl\nRectModes.jl\nAntiresonant.jl\nNonlinearRHS.TransModal\nNonlinearRHS.norm_modal\nLinearOps.make_const_linop\nLinearOps.make_linop","category":"page"},{"location":"model/modal_decompositions.html#Single-mode-guided","page":"Modal decompositions","title":"Single-mode guided","text":"","category":"section"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"In some situations, inter-mode coupling in a waveguide is negligible, so including several waveguide modes in the simulation unnecessarily slows down the computation. Simulating propagation in a single mode is trivially achieved by including only that single mode in both the forward and inverse transforms as defined above for multi-mode propagation. For example, setting modes=1 when calling prop_capillary achieves this and leads to a significant speed-up. However, in this simple implementation, the overlap integral between the nonlinear polarisation and the waveguide mode still needs to be calculated explicitly. We can make this unnecessary by making an assumption about the nonlinear polarisation.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"If the nonlinear polarisation is only due to third-order effects like the Kerr effect or Raman scattering, we can express it as","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"P_mathrmnlleft(t mathbfr_perp z right) = C E(t mathbfr_perp z)^3","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where C is a constant which depends on the specific effect (e.g. for the Kerr effect, C becomes varepsilon_0 chi^(3) with chi^(3) the third-order susceptibility of the nonlinear medium) and we have switched to explicitly real-valued and scalar fields to make the notation simpler; the same result can be obtained with vector fields and more algebra. Expanding the field in terms of its modal content as above, this turns into","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"P_mathrmnlleft(t mathbfr_perp z right) = C Bigsum_j hate_j(mathbfr_perp z) A_j(t z)Big^3","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where we have simply carried out the time-domain inverse Fourier transform to obtain A_j(t z). For a single mode, this simplifies greatly to","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"P_mathrmnlleft(t mathbfr_perp z right) = C hate_0(mathbfr_perp z)^3 A(t z)^3","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Now we can explicitly calculate the overlap integral with the single mode we are considering:","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"beginalign*\nP_mathrmnl(t z) =  CA(t z)^3timesint_S mathrmd^2mathbfr_perp  hate_0^*(mathbfr_perp z) hate_0(mathbfr_perp z)^31em\n= CA(t z)^3int_S mathrmd^2mathbfr_perp  hate_0(mathbfr_perp z)^4\nendalign*","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"where A is now the modal amplitude in the single mode. In the second step we have made use of the fact that we are considering real-valued fields and hence hate_0(mathbfr_perp z) is also real.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"The mode normalisation in Luna is chosen such that the absolute value squared of the modal field amplitudes A_j(t z) is the instantaneous power. For this to be fulfilled, we need","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"frac12 c varepsilon_0 int_S mathrmd^2mathbfr_perp leftvert hate_j(mathbfr_perp z) rightvert^2 = 1","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"This, in turn, means that the effective area of the mode,","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"A_mathrmeff j(z) = fracleft(int_S mathrmd^2mathbfr_perp leftvert hate_j(mathbfr_perp z)rightvert^2right)^2int_S mathrmd^2mathbfr_perp  leftvert hate_j(mathbfr_perp z)rightvert^4","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"for the single mode we are considering is","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"A_mathrmeff = Big(frac14 c^2 varepsilon_0^2 int_S mathrmd^2mathbfr_perp  hate_0(mathbfr_perp z)^4 Big)^-1","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Note that A_mathrmeff is independent of the normalisation, because the overall power of hate_j and any constants inside it is the same in the numerator and denominator. From this we can see that we can replace the integral expression in the projection of P_mathrmnl with","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"int_S mathrmd^2mathbfr_perp  hate_0(mathbfr_perp z)^4 = frac4varepsilon_0^2c^2 A_mathrmeff","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"We can now write down the single-mode UPPE:","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"\npartial_z tildeA(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)tildeA(omega z)\n + ifracomega4 Cfrac4varepsilon_0^2c^2 A_mathrmeff int_-infty^infty mathrmd t A(t z)^3 mathrme^i omega t","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Crucially, the effective area depends on the mode shape hate_0(mathbfr_perp z), but only needs to be calculated once (assuming the cross-section of the waveguide does not change along its length). When only third-order nonlinear effects are present, the single-mode UPPE is exactly equivalent to explicitly solving the projection integral, but much faster. However, it has two important drawbacks:","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"For obvious reasons, inter-modal coupling mediated by the nonlinearity is completely ignored.\nThe equation only works for third-order nonlinear effects, and hence photoionisation and plasma dynamics cannot be modelled in this way.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"We can derive a different single-mode equation which can treat other nonlinear effects approximately. As written above, in the single-mode UPPE only the modal amplitude A appears. We now define a re-scaled mode-averaged field E_mathrmav through","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"A(t z) = sqrtfrac12varepsilon_0 c A_mathrmeffE_mathrmav(t z)","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Note that, because vert A(t z)vert^2 has units of power, E_mathrmav is in fact an electric field (with units of mathrmVm). We can also define the mode-averaged intensity by","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"I_mathrmav = frac12varepsilon_0 c vert E_mathrmavvert^2 = fracvert A(t z)vert^2A_mathrmeff","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Plugging in the definition of E_mathrmav, the UPPE reads","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"beginalign*\nsqrtfrac12varepsilon_0 c A_mathrmeffpartial_z tildeE_mathrmav(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)sqrtfrac12varepsilon_0 c A_mathrmefftildeE_mathrmav(omega z)1em\nqquad + ifracomega4 CBig(frac12varepsilon_0 c A_mathrmeffBig)^frac32frac4varepsilon_0^2c^2 A_mathrmeff int_-infty^infty mathrmd t E_mathrmav(t z)^3 mathrme^i omega t\nendalign*","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"Cancelling the various constants, we arrive at the mode-averaged field UPPE","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"partial_z tildeE_mathrmav(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)tildeE_mathrmav(omega z) + ifracomega4 frac2varepsilon_0 c int_-infty^infty mathrmd t P_mathrmnlleftE_mathrmav(t z)right mathrme^i omega t","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"This now includes only a single inverse Fourier transform to obtain E_mathrmav(t z) followed by the calculation of P_mathrmnl and then a forward transform. This equation is still only valid for third-order responses but we have now written it for an arbitrary polarisation P_mathrmnlleftE_mathrmav(t z)right. Because E_mathrmav is (a version of) the actual electric field, we can calculate arbitrary polarisation contributions, including the photoionisation and plasma term. However, this is still a significant approximation. For example, the mode-averaged intensity is approximately half of the on-axis intensity for the fundamental mode of a capillary fibre. Due to the exponential scaling of strong-field ionisation with intensity, this means that the peak ionisation fraction can be underestimated significantly. Only fully mode-resolved (and multi-mode) propagation can accurately model that situation.","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"The mode-averaged field UPPE as written above is very useful, but the scaling from A to E_mathrmav changes the normalisation: vert E_mathrmav(t z) vert^2 no longer gives the instantaneous power. To remain consistent with modal propagation simulations (e.g. for data analysis), Luna internally uses the same normalisation for both, which leads to a \"hybrid\" equation. The propagating quantity (and hence the simulation output) is A(z t) and we switch to E_mathrmav(z t) to calculate the nonlinear polarisation. This leads to the appearance of an additional factor of in the equation","category":"page"},{"location":"model/modal_decompositions.html","page":"Modal decompositions","title":"Modal decompositions","text":"beginalign*\nleft(frac12varepsilon_0 c A_mathrmeffright)^-frac12partial_z tildeA(omega z) = ileft(frac12varepsilon_0 c A_mathrmeffright)^-frac12 left(fracomegac n_mathrmeff(omega z) - fracomegavright)tildeA(omega z) + ifracomega4 frac2varepsilon_0 c int_-infty^infty mathrmd t P_mathrmnlleftE_mathrmav(t z)right mathrme^i omega t1em\n\nRightarrow partial_ztildeA(omega z) = i left(fracomegac n_mathrmeff(omega z) - fracomegavright)tildeA(omega z) + ifracomega4sqrtfrac2A_mathrmeffvarepsilon_0 c int_-infty^infty mathrmd t P_mathrmnlleftE_mathrmav(t z)right mathrme^i omega t\nendalign*","category":"page"},{"location":"model/modal_decompositions.html#Radially-symmetric-free-space","page":"Modal decompositions","title":"Radially symmetric free-space","text":"","category":"section"},{"location":"model/modal_decompositions.html#Three-dimensional-free-space","page":"Modal decompositions","title":"Three-dimensional free-space","text":"","category":"section"},{"location":"modules/Output.html#Output.jl","page":"Output.jl","title":"Output.jl","text":"","category":"section"},{"location":"modules/Output.html#Luna.Output.GridCondition","page":"Output.jl","title":"Luna.Output.GridCondition","text":"Condition callable that distributes save points evenly on a grid\n\n\n\n\n\n","category":"type"},{"location":"modules/Output.html#Luna.Output.HDF5Output","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Internal constructor - creates the file\n\n\n\n\n\n","category":"type"},{"location":"modules/Output.html#Luna.Output.HDF5Output-2","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Simple constructor\n\n\n\n\n\n","category":"type"},{"location":"modules/Output.html#Luna.Output.HDF5Output-3","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Output handler for writing to an HDF5 file\n\n\n\n\n\n","category":"type"},{"location":"modules/Output.html#Luna.Output.HDF5Output-NTuple{4, Any}","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Calling the output handler writes data to the file     Arguments:         y: current function value         t: current propagation point         dt: current stepsize         yfun: callable which returns interpolated function value at different t     Note that from RK45.jl, this will be called with yn and tn as arguments.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.HDF5Output-Tuple{AbstractDict}","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Calling the output on a dictionary writes the items to the file\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.HDF5Output-Tuple{AbstractString, Any}","page":"Output.jl","title":"Luna.Output.HDF5Output","text":"Calling the output on a key, value pair writes the value to the file\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.MemoryOutput","page":"Output.jl","title":"Luna.Output.MemoryOutput","text":"Output handler for writing only to memory\n\n\n\n\n\n","category":"type"},{"location":"modules/Output.html#Luna.Output.MemoryOutput-NTuple{4, Any}","page":"Output.jl","title":"Luna.Output.MemoryOutput","text":"Calling the output handler saves data in the arrays     Arguments:         y: current function value         t: current propagation point         dt: current stepsize         yfun: callable which returns interpolated function value at different t     Note that from RK45.jl, this will be called with yn and tn as arguments.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.MemoryOutput-Tuple{AbstractString, Any}","page":"Output.jl","title":"Luna.Output.MemoryOutput","text":"Calling the output with a key, value pair writes the value to the array.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.MemoryOutput-Tuple{Dict}","page":"Output.jl","title":"Luna.Output.MemoryOutput","text":"Calling the output on a dictionary writes the items to the array\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Base.getindex-Tuple{Luna.Output.MemoryOutput, AbstractString}","page":"Output.jl","title":"Base.getindex","text":"getindex works interchangeably so when switching from one Output to another, subsequent code can stay the same\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.ScanHDF5Output-Tuple{Any, Any, Vararg{Any}}","page":"Output.jl","title":"Luna.Output.ScanHDF5Output","text":"ScanHDF5Output(scan, scanidx, args...; fname=nothing, fdir=nothing, kwargs...)\n\nCreate an HDF5Output for the given scan at the current scanidx and automatically save the scan arrays and current values of the scan variables in the file. If given, fdir is used as a directory in which to store the scan output. fname can be used to manually name files. The running scan index will be appended to fname for each file.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.always-NTuple{4, Any}","page":"Output.jl","title":"Luna.Output.always","text":"Condition which saves every native point of the propagation\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.check_cache-Tuple{Luna.Output.HDF5Output, Any, Any, Any}","page":"Output.jl","title":"Luna.Output.check_cache","text":"check_cache(o::HDF5Output, y, t, dt)\n\nCheck for an existing cached propagation in the output o and return this cache if present.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.every_nth-Tuple{Any}","page":"Output.jl","title":"Luna.Output.every_nth","text":"Condition which saves every nth native point\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.init_dims-Tuple{Any, Any}","page":"Output.jl","title":"Luna.Output.init_dims","text":"For other conditions, we do not know in advance.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.init_dims-Tuple{Any, Luna.Output.GridCondition}","page":"Output.jl","title":"Luna.Output.init_dims","text":"Making initial array dimensions. For a GridCondition, we know in advance how many points there will be.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.scansave-Tuple{Any, Any}","page":"Output.jl","title":"Luna.Output.scansave","text":"scansave(scan, scanidx; grid, stats, fpath, script, kwargs...)\n\nWhile running the given scan, save the variables given as keyword arguments into the scan grid as determined from the variables of the scan. Special keyword arguments are:\n\ngrid::AbstractGrid: Save the simulation grid in a dictionary (but only once)\nstats: The statistics dictionary from a simulation is saved in scan grid and NaN-padded to account for variable lengths in the output arrays\nfpath: Path to the file. Defaults to the scan name plus \"_collected\"\nscript: Path to the Julia scrpt file running the scan. Can be grabbed automatically using the macro @scansave.\n\nAnother keyword argument lock_stale_age sets the time in seconds after which the function ignores the lock on the file and writes to it anyway. Defaults to 300 s (5 min). (Note that if the PID of the locking process appears valid, this is automatically increased 25x.)\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.scansave_stats_array-Tuple{Any}","page":"Output.jl","title":"Luna.Output.scansave_stats_array","text":"scansave_stats_array(stats_dict)\n\nConvert the statistics dictionary created by scansave into a dictionary containing arrays of arrays. This removes unused elements in the arrays and the need to use valid_length to avoid including NaNs.\n\n\n\n\n\n","category":"method"},{"location":"modules/Output.html#Luna.Output.@ScanHDF5Output-Tuple{Any, Any, Vararg{Any}}","page":"Output.jl","title":"Luna.Output.@ScanHDF5Output","text":"@ScanHDF5Output(scan, scanidx, args...)\n\nCreate an HDF5Output for the given scan at the current scanidx and automatically save the running script, scan arrays, and current values of the scan variables in the file. All arguments, including keyword arguments, after scanidx are identical to HDF5Output.\n\n\n\n\n\n","category":"macro"},{"location":"modules/Output.html#Luna.Output.@scansave-Tuple{Any, Any, Vararg{Any}}","page":"Output.jl","title":"Luna.Output.@scansave","text":"@scansave(scan, scanidx; kwargs...)\n\nLike scansave but also saves the script being run automatically.\n\n\n\n\n\n","category":"macro"},{"location":"modules/Tools.html#Tools.jl","page":"Tools.jl","title":"Tools.jl","text":"","category":"section"},{"location":"modules/Tools.html#Luna.Tools.Ld-Tuple{Any, Any}","page":"Tools.jl","title":"Luna.Tools.Ld","text":"Get dispersion length\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.Lfiss-NTuple{4, Any}","page":"Tools.jl","title":"Luna.Tools.Lfiss","text":"Get fission length\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.Lnl-Tuple{Any, Any}","page":"Tools.jl","title":"Luna.Tools.Lnl","text":"Get nonlinear length\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.getN-NTuple{4, Any}","page":"Tools.jl","title":"Luna.Tools.getN","text":"Get soliton order\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.getN0n0n2-Tuple{Any, Any}","page":"Tools.jl","title":"Luna.Tools.getN0n0n2","text":"Get linear and nonlinear refractive index and gas number density\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.getβ2-Tuple{Any, Luna.Modes.AbstractMode}","page":"Tools.jl","title":"Luna.Tools.getβ2","text":"Get GVD coefficient\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.getγ-Tuple{Any, Luna.Modes.AbstractMode, Any}","page":"Tools.jl","title":"Luna.Tools.getγ","text":"Get nonlinear coefficient\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.params-NTuple{5, Any}","page":"Tools.jl","title":"Luna.Tools.params","text":"Soliton parameter collection\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.pressureRDW-Tuple{Number, Symbol, Any, Any}","page":"Tools.jl","title":"Luna.Tools.pressureRDW","text":"pressureRDW(a::Number, gas::Symbol, λ_target, λ0; Pmax=100, clad=:SiO2, kwargs...)\n\nCalculate the phase-matching pressure for resonant dispersive wave (RDW) emission at λ_target in a capillary with core radius a filled with gas when pumping at λ0. \n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.λRDW-Tuple{Luna.Modes.AbstractMode, Any}","page":"Tools.jl","title":"Luna.Tools.λRDW","text":"λRDW(m::Modes.AbstractMode, λ0; z=0, λlims=(100e-9, 0.9λ0))\nλRDW(mRDW::Modes.AbstractMode, mS::Modes.AbstractMode, λ0; z=0, λlims=(100e-9, 0.9λ0))\n\nCalculate the phase-matching wavelength for resonant dispersive wave (RDW) emission in the mode m when pumping at λ0. If the dispersive-wave mode mRDW and soliton mode mS are given separately, calculate phase-matching for RDW in mode mRDW when pumping in mode mS.\n\nThis neglects the nonlinear contribution to the phase mismatch.\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.λRDW-Tuple{Number, Symbol, Any, Any}","page":"Tools.jl","title":"Luna.Tools.λRDW","text":"λRDW(a::Number, gas::Symbol, pressure, λ0; λlims=(100e-9, 0.9λ0), kwargs...)\n\nCalculate the phase-matching wavelength for resonant dispersive wave (RDW) emission in a  capillary with core radius a filled with gas at a certain pressure when pumping at λ0. Additional kwargs are passed onto Capillary.MarcatiliMode.\n\nThis neglects the nonlinear contribution to the phase mismatch.\n\n\n\n\n\n","category":"method"},{"location":"modules/Tools.html#Luna.Tools.τfw_to_τ0-Tuple{Any, Any}","page":"Tools.jl","title":"Luna.Tools.τfw_to_τ0","text":"Calculate 'natural' pulse width from FWHM\n\n\n\n\n\n","category":"method"},{"location":"index.html#Luna-Documentation","page":"Home","title":"Luna Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This is the documentation for Luna. The README contains installation and quickstart instructions. This documentation is intended to lay out the physical model used give deeper insight into the workings of Luna. It is not yet complete–any contributions are welcome!","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you are new to Luna, the most interesting page is probably the simple interface. Details about the actual equation Luna solves can be found in the numerical model section.","category":"page"}]
}
