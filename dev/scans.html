<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter scans · Luna Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Luna Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">The numerical model</span><ul><li><a class="tocitem" href="model/model.html">General description</a></li><li><a class="tocitem" href="model/modal_decompositions.html">Modal decompositions</a></li><li><a class="tocitem" href="model/nonlinear_responses.html">Nonlinear responses</a></li></ul></li><li><a class="tocitem" href="interface.html">The simple interface</a></li><li class="is-active"><a class="tocitem" href="scans.html">Parameter scans</a><ul class="internal"><li><a class="tocitem" href="#Processing-scan-output"><span>Processing scan output</span></a></li><li><a class="tocitem" href="#Execution-over-SSH"><span>Execution over SSH</span></a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="modules/Antiresonant.html">Antiresonant.jl</a></li><li><a class="tocitem" href="modules/Capillary.html">Capillary.jl</a></li><li><a class="tocitem" href="modules/Fields.html">Fields.jl</a></li><li><a class="tocitem" href="modules/Grid.html">Grid.jl</a></li><li><a class="tocitem" href="modules/Ionisation.html">Ionisation.jl</a></li><li><a class="tocitem" href="modules/LinearOps.html">LinearOps.jl</a></li><li><a class="tocitem" href="modules/Modes.html">Modes.jl</a></li><li><a class="tocitem" href="modules/Nonlinear.html">Nonlinear.jl</a></li><li><a class="tocitem" href="modules/NonlinearRHS.html">NonlinearRHS.jl</a></li><li><a class="tocitem" href="modules/Output.html">Output.jl</a></li><li><a class="tocitem" href="modules/PhysData.html">PhysData.jl</a></li><li><a class="tocitem" href="modules/Plotting.html">Plotting.jl</a></li><li><a class="tocitem" href="modules/Processing.html">Processing.jl</a></li><li><a class="tocitem" href="modules/Raman.html">Raman.jl</a></li><li><a class="tocitem" href="modules/RectModes.html">RectModes.jl</a></li><li><a class="tocitem" href="modules/Scans.html">Scans.jl</a></li><li><a class="tocitem" href="modules/Stats.html">Stats.jl</a></li><li><a class="tocitem" href="modules/Tools.html">Tools.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="scans.html">Parameter scans</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="scans.html">Parameter scans</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LupoLab/Luna.jl/blob/master/docs/src/scans.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Parameter-scans"><a class="docs-heading-anchor" href="#Parameter-scans">Parameter scans</a><a id="Parameter-scans-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-scans" title="Permalink"></a></h1><p>Luna comes with a flexible interface to run, save and process scans over any parameter or combination of parameters you can think of. A simple example can be found in <code>examples/simple_interface/scan.jl</code>, and we will go through it here. There are only a few necessary steps to run a parameter scan.</p><p><strong>First</strong>, define the fixed parameters (those which are not being scanned over):</p><pre><code class="language-julia hljs">using Luna
import PyPlot: plt

a = 125e-6
flength = 3
gas = :HeJ
λ0 = 800e-9
τfwhm = 10e-15
λlims = (100e-9, 4e-6)
trange = 400e-15</code></pre><p><strong>Second</strong>, create the arrays which define your parameter scan. A simulation will be run at every possible combination (the Cartesian product) of these arrays. In this example we will do a pressure-energy scan from 50 μJ to 200 μJ in 16 steps and from 0.6 bar to 1.4 bar in steps of 0.4 bar:</p><pre><code class="language-julia hljs">energies = collect(range(50e-6, 200e-6; length=16))
pressures = collect(0.6:0.4:1.4)</code></pre><p><strong>Third</strong>, create a <code>Scan</code> which will store the scan arrays and define how the scan is executed. You must give this a name. In this case, <code>&quot;pressure_energy_example&quot;</code>. Scan variables like <code>energies</code> and <code>pressures</code> can be passed at construction time or added later:</p><pre><code class="language-julia hljs">scan = Scan(&quot;pressure_energy_example&quot;; energy=energies)
addvariable!(scan, :pressure, pressures)</code></pre><p><strong>Fourth</strong>, run the scan! Here we want to store the output of the scan in a subdirectory of the directory containing the script we&#39;re running to avoid clutter. Passing <code>scan</code> and <code>scanidx</code> to <code>prop_capillary</code> will mean that our output files (one for each simulation) are automatically numbered and some information about the scan being run is also stored.</p><pre><code class="language-julia hljs"># @__DIR__ gives the directory of the current file
outputdir = joinpath(@__DIR__, &quot;scanoutput&quot;)

runscan(scan) do scanidx, energy, pressure
    prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,
                   λlims, trange, scan, scanidx, filepath=outputdir)
end</code></pre><p>Here, <code>runscan</code> uses the <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments">do-block syntax</a>, which wraps its body in a function. In our example this function takes three arguments: <code>scanidx, energy, pressure</code>. Generally, <code>scanidx</code> is always present and uniquely identifies a specific simulation in the scan (it simply runs from 1 to the number of simulations in the scan, <code>length(scan)</code>). The number of subsequent arguments is equal to the number of scan variables you have added to the <code>scan</code>, <strong>and their order must match the order in which variables were added to the scan</strong>. Alternatively, we could also have wrapped our scan in a function ourselves:</p><pre><code class="language-julia hljs">function runone(scanidx, energy, pressure)
   prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,
                   λlims, trange, scan, scanidx, filepath=outputdir)
end
runscan(runone, scan)</code></pre><p>but the <code>do</code> block syntax is exactly equivalent to this and usually easier.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The order in which you add the variables to the scan is important, and it <strong>must</strong> match the arguments in the <code>do</code> block. <code>scan = Scan(&quot;pressure_energy_example&quot;; energy=energies, pressure=pressures)</code> is <strong>not</strong> equivalent to <code>scan = Scan(&quot;pressure_energy_example&quot;; pressure=pressures, energy=energies)</code>.</p></div></div><p>Running this script will simply run all the simulations, one after the other, in the current Julia session. To alter this behaviour, <code>Scan</code> also takes another argument, the execution mode, which has to be a subtype of <code>Scans.AbstractExec</code>. For example, to run only the first 10 items in the scan, we can use a <code>RangeExec</code>:</p><pre><code class="language-julia hljs">scan = Scan(&quot;pressure_energy_example&quot;, Scans.RangeExec(1:10); energy=energies) # note the second argument here
addvariable!(scan, :pressure, pressures)
outputdir = joinpath(@__DIR__, &quot;scanoutput&quot;)

runscan(scan) do scanidx, energy, pressure
    prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,
                   λlims, trange, scan, scanidx, filepath=outputdir)
end</code></pre><p>Scans can be executed in several ways, which are defined via the various subtypes of <code>Scans.AbstractExec</code>:</p><ul><li><a href="modules/Scans.html#Luna.Scans.LocalExec"><code>LocalExec</code></a>: simply run the whole scan on the current machine in a <code>for</code> loop</li><li><a href="modules/Scans.html#Luna.Scans.RangeExec"><code>RangeExec</code></a>: run a subsection of the scan as given by a <code>UnitRange</code> (e.g. <code>1:10</code> for the first 10 elements)</li><li><a href="modules/Scans.html#Luna.Scans.BatchExec"><code>BatchExec</code></a>: divide the scan into batches and run a specific batch (can be used to balance load between processes)</li><li><a href="modules/Scans.html#Luna.Scans.QueueExec"><code>QueueExec</code></a>: create a &quot;queue file&quot; which is used to balance load between several processes. This can be executed from multiple processes simultaneously. Alternatively, <code>QueueExec</code> can be made to spawn several subprocesses on the local machine which then use the queueing system to balance load between them.</li><li><a href="modules/Scans.html#Luna.Scans.CondorExec"><code>CondorExec</code></a>: create a submission file (aka job file) for an HTCondor batch system running on the current machine and submit it, claiming a specified number of nodes, to execute the scan using a <code>QueueExec</code>.</li><li><a href="modules/Scans.html#Luna.Scans.SSHExec"><code>SSHExec</code></a>: use one of the other <code>AbstractExec</code> types but first transfer the file to a remote host via SSH and then execute it. (<strong>Note</strong>: the remote machine must have Julia and Luna available with the same versions of both, and Julia must be available in a shell via the <code>julia</code> command.) For more details on how to set up execution over SSH, see <a href="#execution-over-ssh">below</a>.</li></ul><h3 id="Command-line-arguments"><a class="docs-heading-anchor" href="#Command-line-arguments">Command-line arguments</a><a id="Command-line-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Command-line-arguments" title="Permalink"></a></h3><p>Most of the above execution modes can also be triggered by running the script (the <code>.jl</code> file) from the command line with additional arguments. To show the options, run <code>julia [script] --help</code> where <code>script</code> is your <code>.jl</code> file. As one example, running our <code>scan.jl</code> example in queue-file mode could be accomplished by <code>julia scan.jl --queue</code>, and starting 4 subprocesses to share the queue could be done by <code>julia scan.jl --queue -p 4</code>. Importantly, <strong>command-line arguments passed to the script overwrite any explicitly created execution mode within the script.</strong></p><h3 id="Manual-file-naming"><a class="docs-heading-anchor" href="#Manual-file-naming">Manual file naming</a><a id="Manual-file-naming-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-file-naming" title="Permalink"></a></h3><p>The method we used above of passing the <code>scan</code> and <code>scanidx</code> to <code>prop_capillary</code> is the simplest and most reliable way of creating output files in the correct order and with all the necessary information. If you need something else, for example to run a scan including two sequential propagation simulations, you can pass an additional argument <code>filename</code> to <code>prop_capillary</code>. This will then be used instead of the scan name to automatically name the files. In the low-level interface, this is possible via <a href="modules/Output.html#Luna.Output.ScanHDF5Output-Tuple{Any, Any, Vararg{Any}}"><code>Output.ScanHDF5Output</code></a> (which is used internally by <code>prop_capillary</code>), which takes a keyword argument <code>fname</code>. Both ways store metadata about the scan in each file (the scan arrays and their order, and the resulting shape of the scan grid).</p><h2 id="Processing-scan-output"><a class="docs-heading-anchor" href="#Processing-scan-output">Processing scan output</a><a id="Processing-scan-output-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-scan-output" title="Permalink"></a></h2><p>After the scan is finished, the individual simulations are stored in separate files. <a href="modules/Processing.html#Luna.Processing.scanproc-Tuple{Any, AbstractVector{&lt;:AbstractString}}"><code>Processing.scanproc</code></a> streamlines data processing across the scan by automatically combining the results of a single processing function when applied to all files. Continuing with our pressure-energy scan from above, say we want to plot the output spectrum as a function of energy and pressure. To do this, we can run <code>scanproc</code> like this (again using the <code>do</code>-block syntax)</p><pre><code class="language-julia hljs">λ, Iλ, zstat, edens, max_peakpower = Processing.scanproc(outputdir) do output
    λ, Iλ = Processing.getIω(output, :λ)
    zstat = Processing.VarLength(output[&quot;stats&quot;][&quot;z&quot;])
    edens = Processing.VarLength(output[&quot;stats&quot;][&quot;electrondensity&quot;])
    max_peakpower = maximum(output[&quot;stats&quot;][&quot;peakpower&quot;])
    Processing.Common(λ), Iλ[:, end], zstat, edens, max_peakpower
end</code></pre><p>The function here always takes one argument. This argument is a single read-only <a href="modules/Output.html#Luna.Output.HDF5Output"><code>HDF5Output</code></a> which contains the results from one simulation in the scan. The function then processes the results from this one simulation and returns the results. <code>scanproc</code> will combine the output of this processing function for each individual simulation and place it into a grid of the same shape as the original scan. In this example, <code>Iλ</code> has shape <code>(Nλ, Nenergy, Npressure)</code>, because the output of the function (<code>Iλ[:, end]</code>) has shape <code>(1484,)</code>:</p><pre><code class="language-julia hljs">julia&gt; size(Iλ)
(1484, 16, 3)</code></pre><p>Because the wavelength axis is the same for all outputs, we don&#39;t need to have it repeated. By wrapping it in a <a href="modules/Processing.html#Luna.Processing.Common"><code>Processing.Common</code></a>, we tell <code>scanproc</code> that it only needs to return one instance:</p><pre><code class="language-julia hljs">julia&gt; size(λ)
(1484,)</code></pre><p>With this data, we can now plot the energy-pressure scan:</p><pre><code class="language-julia hljs">fig, axs = plt.subplots(1, length(pressures))
fig.set_size_inches(8, 2)
for (pidx, pressure) in enumerate(pressures)
    ax = axs[pidx]
    global img = ax.pcolormesh(λ*1e9, energies*1e6, 10*Maths.log10_norm(Iλ[:, :, pidx])&#39;)
    img.set_clim(-40, 0)
    ax.set_xlabel(&quot;Wavelength (nm)&quot;)
    ax.set_ylabel(&quot;Energy (μJ)&quot;)
    ax.set_title(&quot;Pressure: $pressure bar&quot;)
    ax.set_xlim(100, 1200)
end
plt.colorbar(img, ax=axs, label=&quot;Energy density (dB)&quot;)</code></pre><p>which will produce this figure: <img src="assets/scan_spectrum.png" alt="Scan spectra"/></p><p>Some outputs from the function may not have the same length for each simulation. For example, the length of propagation statistics arrays depends on how many steps were required in the simulation. To deal with this, we can use <a href="modules/Processing.html#Luna.Processing.VarLength"><code>Processing.VarLength</code></a>. Rather than a single multi-dimensional array like <code>Iλ</code>, <code>scanproc</code> will place the results into an array of arrays:</p><pre><code class="language-julia hljs">julia&gt; typeof(edens)
Array{Array{Float64,1},2}

julia&gt; size(edens)
(16, 3)

julia&gt; size(edens[1, 1])
(169,)

julia&gt; size(edens[1, 2])
(235,)</code></pre><p>For return values which are scalar, like the maximim peak power <code>max_peakpower</code> in our example, the resulting array simply has shape <code>(Nenergy, Npressure)</code>:</p><pre><code class="language-julia hljs">julia&gt; size(max_peakpower)
(16, 3)</code></pre><h3 id="Processing-scan-results-at-runtime"><a class="docs-heading-anchor" href="#Processing-scan-results-at-runtime">Processing scan results at runtime</a><a id="Processing-scan-results-at-runtime-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-scan-results-at-runtime" title="Permalink"></a></h3><p>Sometimes it is not useful or required to store the whole propagation output for each simulation, but only some result from the simulation is needed. For example, we may only be interested in the output field and not its evolution along the propagation. Especially if we&#39;re running very many simulations, storing the evolution and then extracting only the last slice is very inefficient. To make this easy, you can use <a href="modules/Output.html#Luna.Output.scansave-Tuple{Any, Any}"><code>Output.scansave</code></a>. This has to be executed within <code>runscan</code> and places arrays and numbers into a grid similarly to <code>scanproc</code>. For instance, to just store the final slice of the frequency-domain field from each simulation, along with the simulation grid, we could have used</p><pre><code class="language-julia hljs">runscan(scan) do scanidx, energy, pressure
    output = prop_capillary(a, flength, gas, pressure; λ0, τfwhm, energy,
                            λlims, trange)
    Output.scansave(scan, scanidx; grid=output[&quot;grid&quot;],
                                   Εω=output[&quot;Eω&quot;][:, end])
end</code></pre><p>Note here that <code>scan</code> and <code>scanidx</code> are not given to <code>prop_capillary</code>, so our <code>output</code> lives purely in memory without being saved to disk. If <code>fpath</code> is not explicitly given as a keyword argument to <code>scansave</code>, it automatically names the file. Here it&#39;s called <code>pressure_energy_example_collected.h5</code> and is stored in the current working directory. This file then contains only the grid, the field <code>Eω</code>, and some metadata about the scan:</p><pre><code class="language-julia hljs">julia&gt; HDF5.h5open(&quot;pressure_energy_example_collected.h5&quot;, &quot;r&quot;) do fi
         println(keys(fi))
         println(size(fi[&quot;Εω&quot;]))
       end
[&quot;grid&quot;, &quot;scanorder&quot;, &quot;scanvariables&quot;, &quot;Εω&quot;]
(2049, 16, 3)</code></pre><p>Importantly, in our example here this file is less than one megabyte in size, whereas the <code>scanoutput</code> folder totals over 600 megabytes. To store the statistics as well, <code>stats</code> can be given as a special keyword argument to <code>scansave</code>. Because the arrays are not always the same size (see above), in the file these are stored in an array which is large enough to fit the longest and padded with <code>NaN</code>s. The number of actual statisics points available for each simulation is then stored in a special dataset <code>valid_length</code>.</p><h2 id="Execution-over-SSH"><a class="docs-heading-anchor" href="#Execution-over-SSH">Execution over SSH</a><a id="Execution-over-SSH-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-over-SSH" title="Permalink"></a></h2><p>Setup steps required:</p><ul><li>On the remote machine, add Julia to your path upon loading even over SSH: add <code>export PATH=/opt/julia-1.5.1/bin:$PATH</code> or similar to your <code>.bashrc</code> file <strong>above</strong> the usual check for interactive running.</li><li>On Windows, the default version of OpenSSH is v7, but OpenSSH v8 is required to work from within Julia. To install it:<ul><li>Follow <a href="https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH">these instructions</a> to install the new version.</li><li><strong>Uninstall</strong> OpenSSH via <a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Windows Features</a>. This removes OpenSSH 7 so that Windows finds OpenSSH 8 instead.</li></ul></li><li>Set up a public/private key pair to enable SSH login without entering a password.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interface.html">« The simple interface</a><a class="docs-footer-nextpage" href="modules/Antiresonant.html">Antiresonant.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 2 June 2023 13:42">Friday 2 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
