<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Processing.jl · Luna Documentation</title><meta name="title" content="Processing.jl · Luna Documentation"/><meta property="og:title" content="Processing.jl · Luna Documentation"/><meta property="twitter:title" content="Processing.jl · Luna Documentation"/><meta name="description" content="Documentation for Luna Documentation."/><meta property="og:description" content="Documentation for Luna Documentation."/><meta property="twitter:description" content="Documentation for Luna Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Luna Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">The numerical model</span><ul><li><a class="tocitem" href="../model/model.html">General description</a></li><li><a class="tocitem" href="../model/modal_decompositions.html">Modal decompositions</a></li><li><a class="tocitem" href="../model/nonlinear_responses.html">Nonlinear responses</a></li></ul></li><li><a class="tocitem" href="../interface.html">The simple interface</a></li><li><a class="tocitem" href="../scans.html">Parameter scans</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="Antiresonant.html">Antiresonant.jl</a></li><li><a class="tocitem" href="Capillary.html">Capillary.jl</a></li><li><a class="tocitem" href="Fields.html">Fields.jl</a></li><li><a class="tocitem" href="Grid.html">Grid.jl</a></li><li><a class="tocitem" href="Ionisation.html">Ionisation.jl</a></li><li><a class="tocitem" href="LinearOps.html">LinearOps.jl</a></li><li><a class="tocitem" href="Modes.html">Modes.jl</a></li><li><a class="tocitem" href="Nonlinear.html">Nonlinear.jl</a></li><li><a class="tocitem" href="NonlinearRHS.html">NonlinearRHS.jl</a></li><li><a class="tocitem" href="Output.html">Output.jl</a></li><li><a class="tocitem" href="PhysData.html">PhysData.jl</a></li><li><a class="tocitem" href="Plotting.html">Plotting.jl</a></li><li class="is-active"><a class="tocitem" href="Processing.html">Processing.jl</a></li><li><a class="tocitem" href="Raman.html">Raman.jl</a></li><li><a class="tocitem" href="RectModes.html">RectModes.jl</a></li><li><a class="tocitem" href="Scans.html">Scans.jl</a></li><li><a class="tocitem" href="Stats.html">Stats.jl</a></li><li><a class="tocitem" href="Tools.html">Tools.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href="Processing.html">Processing.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Processing.html">Processing.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/LupoLab/Luna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/LupoLab/Luna.jl/blob/master/docs/src/modules/Processing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Processing.jl"><a class="docs-heading-anchor" href="#Processing.jl">Processing.jl</a><a id="Processing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Processing.jl" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="Luna.Processing.AutoWindow"><a class="docstring-binding" href="#Luna.Processing.AutoWindow"><code>Luna.Processing.AutoWindow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AutoWindow(width, λmin, λmax, ω0fun; relative=false, ndims=1)</code></pre><p>Window function generator which automatically tracks the central frequency in the spectral region given by <code>λmin</code> and <code>λmax</code> and applies a window of a specific <code>width</code> around the peak. The central frequency is found using the function <code>ω0fun(ω, Iω::AbstractVector)</code>, where <code>ω</code> and <code>Iω</code> are already cropped to within the wavelength limits given. If <code>relative</code> is <code>true</code>, <code>width</code> is relative bandwidth instead of the wavelength width. <code>ndims</code> determines how many dimensions of the array to sum over. For a field array with size <code>(Nω, N1, N2, ...)</code>, the first dimension is always assumed to be frequency. <code>ndim=1</code> means each field to be analysed is 1-dimensional, so the window iterates over all of <code>(N1, N2, ...)</code>. <code>ndim=2</code> means each field to be analysed is 2-dimensional, <code>(Nω, N1)</code> in size, and will be  summed over its second dimension before finding the central frequency. The window iterates over all other dimensions, <code>(N2, ...)</code>.</p><p>A <code>AutoWindow</code> automatically stores the limits of the windows it applies in the field <code>lims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L713-L729">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.Common"><a class="docstring-binding" href="#Luna.Processing.Common"><code>Luna.Processing.Common</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Common(val)</code></pre><p>Wrapper type to tell <code>scanproc</code> that <code>val</code> is the same for each simulation being processed, and so only needs to be returned once rather than for each simulation in the scan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.VarLength"><a class="docstring-binding" href="#Luna.Processing.VarLength"><code>Luna.Processing.VarLength</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VarLength(val)</code></pre><p>Wrapper type to tell <code>scanproc</code> that the shape of <code>val</code> is different for each simulation being processed. Return values wrapped in <code>VarLength</code> will be placed in an array of arrays.</p><div class="admonition is-info" id="Note-55313e86c4d0a140"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-55313e86c4d0a140" title="Permalink"></a></header><div class="admonition-body"><p>While the <strong>shape</strong> of <code>val</code> can be different between simulations, the <strong>type</strong> must be the same, including the dimensionality and element type of arrays.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L24-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.CentroidWindow-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Luna.Processing.CentroidWindow-Tuple{Any, Any, Any}"><code>Luna.Processing.CentroidWindow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CentroidWindow(width, λmin, λmax; relative=false, ndims=1, power=1)</code></pre><p>An <a href="Processing.html#Luna.Processing.AutoWindow"><code>AutoWindow</code></a> which uses the centroid (centre of mass or first moment) of the spectral energy density as the central frequency. Before calculating the centroid, the  SED is raised to the <code>power</code> given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L775-L781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.PeakWindow-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Luna.Processing.PeakWindow-Tuple{Any, Any, Any}"><code>Luna.Processing.PeakWindow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PeakWindow(width, λmin, λmax; relative=false, ndims=1)</code></pre><p>An <a href="Processing.html#Luna.Processing.AutoWindow"><code>AutoWindow</code></a> which uses the peak of the spectral energy density as the central frequency. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L764-L769">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing._specres_kernel!-NTuple{9, Any}"><a class="docstring-binding" href="#Luna.Processing._specres_kernel!-NTuple{9, Any}"><code>Luna.Processing._specres_kernel!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Convolution kernel for each output point. We simply loop over all outer indices and output points. The inner loop adds up the contributions from the specified window around the target point. Note that this works without scaling also for wavelength ranges because the integral is still over a frequency grid (with appropriate frequency dependent integration bounds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L481-L487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.arrivaltime-Tuple{Luna.Grid.AbstractGrid, Any}"><a class="docstring-binding" href="#Luna.Processing.arrivaltime-Tuple{Luna.Grid.AbstractGrid, Any}"><code>Luna.Processing.arrivaltime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">arrivaltime(grid, Eω; bandpass=nothing, method=:moment, oversampling=1)</code></pre><p>Extract the arrival time of the pulse in the wavelength limits <code>λlims</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bandpass</code> : method to bandpass the field if required. See <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a></li><li><code>method::Symbol</code> : <code>:moment</code> to use 1st moment to extract arrival time, <code>:peak</code> to use                   the time of peak power</li><li><code>oversampling::Int</code> : If &gt;1, oversample the time-domain field before extracting delay</li><li><code>sumdims</code> : Single <code>Int</code> or <code>Tuple</code> of <code>Int</code>s. The time-domain power will be summed over           these dimensions (e.g. modes) before extracting the arrival time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L204-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.beam-NTuple{4, Any}"><a class="docstring-binding" href="#Luna.Processing.beam-NTuple{4, Any}"><code>Luna.Processing.beam</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">beam(grid, Eωm, modes, x, y; z=0, components=:xy)
beam(output, x, y, zslice; bandpass=nothing)</code></pre><p>Calculate the beam profile of the multi-mode field <code>Eωm</code> on the grid given by spatial coordinates <code>x</code> and <code>y</code>. If <code>output</code> is given, create the <code>modes</code> from that and take the field nearest propagation slice <code>zslice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L945-L952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.coherence-Tuple{Any}"><a class="docstring-binding" href="#Luna.Processing.coherence-Tuple{Any}"><code>Luna.Processing.coherence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coherence(Eω; ndim=1)</code></pre><p>Calculate the first-order coherence function g₁₂ of the set of fields <code>Eω</code>. The ensemble average is taken over the last <code>ndim</code> dimensions of <code>Eω</code>, other dimensions are preserved.</p><p>See J. M. Dudley and S. Coen, Optics Letters 27, 1180 (2002).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L172-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.coherence_time-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.coherence_time-Tuple{Any, Any}"><code>Luna.Processing.coherence_time</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coherence_time(grid, Et; dims=1)</code></pre><p>Get the coherence time of a field <code>Et</code> over <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L389-L393">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.energy-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.energy-Tuple{Any, Any}"><code>Luna.Processing.energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">energy(grid, Eω; bandpass=nothing)
energy(output; bandpass=nothing)</code></pre><p>Extract energy. If <code>bandpass</code> is given, bandpass the field according to <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L337-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.envelope-Tuple{Luna.Grid.RealGrid, Any}"><a class="docstring-binding" href="#Luna.Processing.envelope-Tuple{Luna.Grid.RealGrid, Any}"><code>Luna.Processing.envelope</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">envelope(grid, Eω)</code></pre><p>Get the envelope electric field including the carrier wave from the frequency-domain field <code>Eω</code> sampled on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L812-L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.field_autocorrelation-Tuple{Any, Luna.Grid.EnvGrid}"><a class="docstring-binding" href="#Luna.Processing.field_autocorrelation-Tuple{Any, Luna.Grid.EnvGrid}"><code>Luna.Processing.field_autocorrelation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">field_autocorrelation(Et; dims=1)</code></pre><p>Calculate the field autocorrelation of <code>Et</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L366-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.fwhm_f-Tuple{Luna.Grid.AbstractGrid, Any}"><a class="docstring-binding" href="#Luna.Processing.fwhm_f-Tuple{Luna.Grid.AbstractGrid, Any}"><code>Luna.Processing.fwhm_f</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fwhm_f(grid, Eω::Vector; bandpass=nothing, oversampling=1, sumdims=nothing, minmax=:min)</code></pre><p>Extract the frequency FWHM. If <code>bandpass</code> is given, bandpass the field according to <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a>. If <code>sumdims</code> is given, the energy density is summed over these dimensions (e.g. modes) before extracting the FWHM. <code>minmax</code> determines determines whether the FWHM is taken at the narrowest (<code>:min</code>) or the widest (<code>:max</code>) point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L285-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.fwhm_t-Tuple{Luna.Grid.AbstractGrid, Any}"><a class="docstring-binding" href="#Luna.Processing.fwhm_t-Tuple{Luna.Grid.AbstractGrid, Any}"><code>Luna.Processing.fwhm_t</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fwhm_t(grid::AbstractGrid, Eω; bandpass=nothing, oversampling=1, sumdims=nothing, minmax=:min)</code></pre><p>Extract the temporal FWHM. If <code>bandpass</code> is given, bandpass the fieldaccording to <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a>. If <code>oversampling</code> &gt; 1, the  time-domain field is oversampled before extracting the FWHM. If <code>sumdims</code> is given, the time-domain power is summed over these dimensions (e.g. modes) before extracting the FWHM. <code>minmax</code> determines determines whether the FWHM is taken at the narrowest (<code>:min</code>) or the widest (<code>:max</code>) point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L261-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getEt-Tuple{Luna.Grid.AbstractGrid, AbstractArray}"><a class="docstring-binding" href="#Luna.Processing.getEt-Tuple{Luna.Grid.AbstractGrid, AbstractArray}"><code>Luna.Processing.getEt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getEt(grid, Eω; trange=nothing, oversampling=4, bandpass=nothing, FTL=false)</code></pre><p>Get the envelope time-domain electric field (including the carrier wave) from the frequency- domain field <code>Eω</code>. The field can be cropped in time using <code>trange</code>, it is oversampled by a factor of <code>oversampling</code> (default 4) and can be bandpassed with <code>bandpass</code> (see <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a>). If <code>FTL</code> is <code>true</code>, return the Fourier-transform limited pulse, i.e. remove any spectral phase.</p><p>If <code>zslice</code> is given, returs only the slices of <code>Eω</code> closest to the given distances. <code>zslice</code> can be a single number or an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L672-L683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getEt-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}"><a class="docstring-binding" href="#Luna.Processing.getEt-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}"><code>Luna.Processing.getEt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getEt(output[, zslice]; kwargs...)</code></pre><p>Get the envelope time-domain electric field (including the carrier wave) from the <code>output</code>. If <code>zslice</code> is given, returs only the slices of <code>Eω</code> closest to the given distances. <code>zslice</code> can be a single number or an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L662-L668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getEtxy-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Luna.Processing.getEtxy-Tuple{Any, Any, Any}"><code>Luna.Processing.getEtxy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getEtxy(output, xs, z; kwargs...)
getEtxy(Etm, modes, xs, z; components=:xy)</code></pre><p>Calculate the time-dependent electric field at transverse position <code>xs</code> and longitudinal position <code>z</code> from either the modal time-dependent field <code>Etm</code> or the given <code>output</code>.</p><p><code>xs</code> should be a 2-Tuple of coordinates–either <code>(r, θ)</code> for polar coordinates or <code>(x, y)</code> in Cartesian coordinates, depending on the coordinate system of the <code>modes</code>–or a 2-Tuple of vectors containing the coordinates. If vectors are given, the output contains values of Etxy at all combinations of the coordinates.</p><p>Additional keyword arguments to <code>getEtxy(output, ...)</code> are passed through to <code>Processing.getEt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L981-L994">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getEω-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}"><a class="docstring-binding" href="#Luna.Processing.getEω-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}"><code>Luna.Processing.getEω</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getEω(output[, zslice])</code></pre><p>Get frequency-domain modal field from <code>output</code> with correct normalisation (i.e.  <code>abs2.(Eω)</code>` gives angular-frequency spectral energy density in J/(rad/s)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L595-L600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getIω-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Luna.Processing.getIω-Tuple{Any, Any, Any}"><code>Luna.Processing.getIω</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getIω(ω, Eω, specaxis; specrange=nothing, resolution=nothing)</code></pre><p>Get spectral energy density and x-axis given a frequency array <code>ω</code> and frequency-domain field <code>Eω</code>, assumed to be correctly normalised (see <a href="Processing.html#Luna.Processing.getEω-Tuple{Luna.Output.AbstractOutput, Vararg{Any}}"><code>getEω</code></a>). <code>specaxis</code> determines the x-axis:</p><ul><li>:f -&gt; x-axis is frequency in Hz and Iω is in J/Hz</li><li>:ω -&gt; x-axis is angular frequency in rad/s and Iω is in J/(rad/s)</li><li>:λ -&gt; x-axis is wavelength in m and Iω is in J/m</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>specrange::Tuple</code> can be set to a pair of limits on the spectral range (in <code>specaxis</code> units).</li><li><code>resolution::Real</code> is set, smooth the spectral energy density as defined by <a href="Processing.html#Luna.Processing.specres-NTuple{5, Any}"><code>specres</code></a>.</li></ul><p>Note that if <code>resolution</code> and <code>specaxis=:λ</code> is set it is highly recommended to also set <code>specrange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L527-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getIω-Tuple{Luna.Output.AbstractOutput, Any}"><a class="docstring-binding" href="#Luna.Processing.getIω-Tuple{Luna.Output.AbstractOutput, Any}"><code>Luna.Processing.getIω</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getIω(output, specaxis[, zslice]; kwargs...)</code></pre><p>Calculate the correctly normalised frequency-domain field and convert it to spectral energy density on x-axis <code>specaxis</code> (<code>:f</code>, <code>:ω</code>, or <code>:λ</code>). If <code>zslice</code> is given, returs only the slices of <code>Eω</code> closest to the given distances. <code>zslice</code> can be a single number or an array. <code>specaxis</code> determines the x-axis:</p><ul><li>:f -&gt; x-axis is frequency in Hz and Iω is in J/Hz</li><li>:ω -&gt; x-axis is angular frequency in rad/s and Iω is in J/(rad/s)</li><li>:λ -&gt; x-axis is wavelength in m and Iω is in J/m</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>specrange::Tuple</code> can be set to a pair of limits on the spectral range (in <code>specaxis</code> units).</li><li><code>resolution::Real</code> is set, smooth the spectral energy density as defined by <a href="Processing.html#Luna.Processing.specres-NTuple{5, Any}"><code>specres</code></a>.</li></ul><p>Note that <code>resolution</code> is set and <code>specaxis=:λ</code> it is highly recommended to also set <code>specrange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L568-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getφ-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#Luna.Processing.getφ-Tuple{Any, Vararg{Any}}"><code>Luna.Processing.getφ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getφ(output, args...)</code></pre><p>Extract the frequency-domain <code>Eω</code> from the <code>output</code> (additional <code>args...</code> are passed to <code>getEω</code>) and extract the spectral phase, subtracting the linear phase ramp corresponding to a pulse in the middle of the time window defined by the frequency grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L647-L653">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.getφ-Tuple{Luna.Grid.AbstractGrid, Any}"><a class="docstring-binding" href="#Luna.Processing.getφ-Tuple{Luna.Grid.AbstractGrid, Any}"><code>Luna.Processing.getφ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getφ(grid, Eω)
getφ(ω, Eω, τ)</code></pre><p>Extract the unwrapped spectral phase from the field <code>Eω</code>, subtracting the linear phase ramp corresponding to a pulse in the middle of the time window defined by the <code>grid</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L628-L634">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.intensity_autocorrelation-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.intensity_autocorrelation-Tuple{Any, Any}"><code>Luna.Processing.intensity_autocorrelation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intensity_autocorrelation(Et, grid)</code></pre><p>Calculate the intensity autocorrelation of <code>Et</code> over <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L380-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.ionisation_fraction-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.ionisation_fraction-Tuple{Any, Any}"><code>Luna.Processing.ionisation_fraction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ionisation_fraction(output, xs; ratefun, oversampling=1)
ionisation_fraction(output; ratefun, oversampling=1, maxevals=1000)</code></pre><p>Calculate the ionisation fraction at transverse coordinates <code>xs</code> using the ionisation-rate function <code>ratefun</code>. If <code>xs</code> is not given, calculate the average ionisation fraction across the waveguide core. In this case, <code>maxevals</code> determines the maximum number of function evaluations for the integral.</p><div class="admonition is-warning" id="Warning-1c27ef812d6f035a"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1c27ef812d6f035a" title="Permalink"></a></header><div class="admonition-body"><p>Calculating the average ionisation fraction is <strong>much</strong> slower than calculating it at a single point</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L1028-L1040">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.makegrid-Tuple{Any}"><a class="docstring-binding" href="#Luna.Processing.makegrid-Tuple{Any}"><code>Luna.Processing.makegrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">makegrid(output)</code></pre><p>Create an <code>AbstractGrid</code> from the <code>&quot;grid&quot;</code> dictionary saved in <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L821-L825">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.makemodes-Tuple{Any}"><a class="docstring-binding" href="#Luna.Processing.makemodes-Tuple{Any}"><code>Luna.Processing.makemodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">makemodes(output)</code></pre><p>Create the modes used in a simulation using <code>MarcatiliMode</code>s. If <code>output</code> was created by <a href="../interface.html#Luna.Interface.prop_capillary_args-NTuple{4, Any}"><code>Interface.prop_capillary_args</code></a> and hence has a field <code>prop_capillary_args</code>, this is used to match the gas fill from the simulation. Otherwise, the modes are created without gas fill.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L834-L841">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.nearest_z-Tuple{Any, Number}"><a class="docstring-binding" href="#Luna.Processing.nearest_z-Tuple{Any, Number}"><code>Luna.Processing.nearest_z</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nearest_z(output, z)</code></pre><p>Return the index of saved z-position(s) closest to the position(s) <code>z</code>. Output is always an array, even if <code>z</code> is a number. If <code>z</code> is negative, its absolute value is taken as the fraction of the total propagation distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L1087-L1093">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.peakpower-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.peakpower-Tuple{Any, Any}"><code>Luna.Processing.peakpower</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">peakpower(grid, Eω; bandpass=nothing, oversampling=1, sumdims=nothing)
peakpower(output; bandpass=nothing, oversampling=1, sumdims=nothing)</code></pre><p>Extract the peak power. If <code>bandpass</code> is given, bandpass the field according to <a href="Processing.html#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>window_maybe</code></a>. If <code>sumdims</code> is not <code>nothing</code>, sum the time-dependent power over these dimensions (e.g. modes) before taking the maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L314-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.scanproc-Tuple{Any, AbstractVector{&lt;:AbstractString}}"><a class="docstring-binding" href="#Luna.Processing.scanproc-Tuple{Any, AbstractVector{&lt;:AbstractString}}"><code>Luna.Processing.scanproc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scanproc(f, scanfiles)
scanproc(f, directory)
scanproc(f, directory, pattern)
scanproc(f)</code></pre><p>Iterate over the scan output files, apply the processing function <code>f(o::AbstractOutput)</code>, and collect the results in arrays.</p><p>The files can be given as:</p><ul><li>a <code>Vector</code> of <code>AbstractString</code>s containing file paths</li><li>a directory to search for files according to the naming pattern of   <code>Output.ScanHDF5Output</code></li><li>a directory and a <code>glob</code> pattern</li></ul><p>If nothing is specified, <code>scanproc</code> uses the current working directory.</p><p><code>f</code> can return a single value, an array, or a tuple/array of arrays/numbers. Arrays returned by <code>f</code> must either be of the same size for each processed file, or wrapped in a <code>VarLength</code>. Values returned by <code>f</code> which are guaranteed to be identical for each processed file can be wrapped in a <code>Common</code>, and <code>scanproc</code> only returns these once.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Et, Eω = scanproc(&quot;path/to/scandir&quot;) do output
    t, Et = getEt(output)
    ω, Eω = getEω(output)
    energyout = energyout = Processing.VarLength(output[&quot;stats&quot;][&quot;energy&quot;])
    Common(t), Et, Common(ω), Eω, energyout
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L38-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.scanproc-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.scanproc-Tuple{Any, Any}"><code>Luna.Processing.scanproc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scanproc(f, outputs; shape=nothing)</code></pre><p>Iterate over the scan outputs, apply the processing function <code>f(o::AbstractOutput)</code>, and collect the results in arrays.</p><p>If the <code>outputs</code> are <code>MemoryOutput</code>s which do not contain the scan metadata, the <code>shape</code> of the scan must be given explicitly (e.g. via <code>size(scan)</code>).</p><p><code>f</code> can return a single value, an array, or a tuple/array of arrays/numbers. Arrays returned by <code>f</code> must either be of the same size for each processed output, or wrapped in a <code>VarLength</code>. Values returned by <code>f</code> which are guaranteed to be identical for each processed output can be wrapped in a <code>Common</code>, and <code>scanproc</code> only returns these once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L97-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.specres-NTuple{5, Any}"><a class="docstring-binding" href="#Luna.Processing.specres-NTuple{5, Any}"><code>Luna.Processing.specres</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">specres(ω, Iω, specaxis, resolution, specrange; window=nothing, nsamples=10)</code></pre><p>Smooth the spectral energy density <code>Iω(ω)</code> to account for the given <code>resolution</code> on the defined <code>specaxis</code> and <code>specrange</code>. The <code>window</code> function to use defaults to a Gaussian function with FWHM of <code>resolution</code>, and by default we sample <code>nsamples=10</code> times within each <code>resolution</code>.</p><p>Note that you should prefer the <code>resolution</code> keyword of <a href="Processing.html#Luna.Processing.getIω-Tuple{Any, Any, Any}"><code>getIω</code></a> instead of calling this function directly.</p><p>The input <code>ω</code> and <code>Iω</code> should be as returned by <a href="Processing.html#Luna.Processing.getIω-Tuple{Any, Any, Any}"><code>getIω</code></a> with <code>specaxis = :ω</code>.</p><p>Returns the new specaxis grid and smoothed spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L398-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.time_bandwidth-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.time_bandwidth-Tuple{Any, Any}"><code>Luna.Processing.time_bandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_bandwidth(grid, Eω; bandpass=nothing, oversampling=1)</code></pre><p>Extract the time-bandwidth product, after bandpassing if required. The TBP is defined here as ΔfΔt where Δx is the FWHM of x. (In this definition, the TBP of  a perfect Gaussian pulse is ≈0.44). If <code>oversampling</code> &gt; 1, the time-domain field is oversampled before extracting the FWHM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L246-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><a class="docstring-binding" href="#Luna.Processing.window_maybe-Tuple{Any, Any, Nothing}"><code>Luna.Processing.window_maybe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">window_maybe(ω, Eω, win)</code></pre><p>Apply a frequency window to the field <code>Eω</code> if required. Possible values for <code>win</code>:</p><ul><li><code>nothing</code> : no window is applied</li><li>4-<code>Tuple</code> of <code>Number</code>s : the 4 parameters for a <code>Maths.planck_taper</code> in <strong>wavelength</strong></li><li>3-<code>Tuple</code> of <code>Number</code>s : minimum, maximum <strong>wavelength</strong>, and smoothing in <strong>radial frequency</strong></li><li>2-<code>Tuple</code> of <code>Number</code>s : minimum and maximum <strong>wavelength</strong> with automatically chosen smoothing</li><li><code>Vector{&lt;:Real}</code> : a pre-defined window function (shape must match <code>ω</code>)</li><li><code>PeakWindow</code> : automatically track the peak in a given range and apply the window around it</li><li><code>window(ω, Eω)</code> : an arbitrary user-supplied window function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L787-L799">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Luna.Processing.ωwindow_λ-Tuple{Any, Any}"><a class="docstring-binding" href="#Luna.Processing.ωwindow_λ-Tuple{Any, Any}"><code>Luna.Processing.ωwindow_λ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ωwindow_λ(ω, λlims; winwidth=:auto)</code></pre><p>Create a ω-axis filtering window to filter in <code>λlims</code>. <code>winwidth</code>, if a <code>Number</code>, sets the smoothing width of the window in rad/s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LupoLab/Luna.jl/blob/8e735242709cd68d39e5925bda8f5a4ee6725310/src/Processing.jl#L515-L520">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Plotting.html">« Plotting.jl</a><a class="docs-footer-nextpage" href="Raman.html">Raman.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 31 January 2026 09:33">Saturday 31 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
